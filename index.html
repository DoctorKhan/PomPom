<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PomPom - A productivity timer for remote teams</title>
    <script src="firebase-config.js" onerror="console.warn('Firebase config not found - running in offline mode')"></script>
    <link href="/styles.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <!-- Favicon to prevent 404s when developing locally -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50' font-size='48'%3E%E2%98%81%EF%B8%8F%3C/text%3E%3C/svg%3E">
    <!-- Custom styles are now built with Tailwind CLI into styles.css -->
    <style>
        .glassmorphism {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body class="text-sky-900 bg-sparkles">

    <!-- App container -->
    <div id="app" class="h-screen w-screen flex items-center justify-center p-4 relative">
    <!-- Floating kawaii decorations (emoji-based to avoid external requests) -->
    <div aria-hidden="true" class="fixed top-10 left-10 w-16 h-16 kawaii-float opacity-40 text-4xl select-none" style="animation-delay: 0s">☁️</div>
    <div aria-hidden="true" class="fixed top-20 right-20 w-12 h-12 kawaii-float opacity-40 text-2xl select-none" style="animation-delay: 1s">✨</div>
    <div aria-hidden="true" class="fixed bottom-20 left-20 w-20 h-16 kawaii-float opacity-40 text-5xl select-none" style="animation-delay: 2s">☁️</div>


        <!-- Landing Page -->
        <div id="landing-page" class="text-center">
            <!-- Cloud Pomeranian mascot with kawaii elements -->
            <div class="mb-6">
                <div class="relative">
                    <div class="w-32 h-32 mx-auto mb-4 kawaii-float rounded-full border-4 border-white/50 shadow-lg bg-white/50 flex items-center justify-center text-6xl" aria-hidden="true">☁️🐕☁️</div>
                </div>
                <div class="flex justify-center gap-4 mb-4">
                    <div class="w-8 h-8 bg-gradient-to-br from-yellow-200 to-yellow-400 rounded-full pom-pom-bounce shadow-lg flex items-center justify-center">✨</div>
                    <div class="w-8 h-8 bg-gradient-to-br from-pink-200 to-pink-400 rounded-full pom-pom-bounce shadow-lg flex items-center justify-center" style="animation-delay: 0.5s">💫</div>
                </div>
            </div>
            <h1 class="text-5xl md:text-7xl font-bold mb-2">Welcome to PomPom ✨</h1>
            <p class="text-xl md:text-2xl text-sky-700 mb-8">A productivity timer for remote teams with fluffy cloud spirit!</p>
            <p class="text-lg text-sky-700 mb-2 uppercase tracking-widest">Create or join a session</p>
            <div class="flex items-center justify-center max-w-md mx-auto">
                <span class="text-lg bg-white/20 px-4 py-3 rounded-l-lg text-sky-800 font-semibold">pompom.io/</span>
                <input id="session-name-input" type="text" placeholder="team-name (or leave blank)" class="w-full bg-white text-sky-800 px-4 py-3 focus:outline-none placeholder-sky-400">
                <button id="create-session-btn" class="bg-white text-sky-600 px-4 py-3 rounded-r-lg font-bold hover:bg-sky-50 transition-colors shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 8a.5.5 0 0 1 .5-.5h5.793L8.146 5.354a.5.5 0 1 1 .708-.708l3 3a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708-.708L10.293 8.5H4.5A.5.5 0 0 1 4 8z"/></svg>
                </button>
            </div>
        </div>

        <!-- Name Input Page -->
        <div id="name-input-page" class="hidden text-center">
            <!-- Cloud Pomeranian mascot with pom poms -->
            <div class="max-w-2xl mx-auto glassmorphism rounded-2xl shadow-2xl p-6 md:p-10">
                <div class="mb-6">
                    <div class="relative">
                        <div class="w-24 h-24 mx-auto mb-4 kawaii-float rounded-full border-4 border-white/50 shadow-lg bg-white/50 flex items-center justify-center text-5xl" aria-hidden="true">☁️🐕☁️</div>
                    </div>
                    <div class="flex justify-center gap-2 mb-4">
                        <div class="w-6 h-6 bg-gradient-to-br from-red-200 to-pink-400 rounded-full pom-pom-bounce shadow-md flex items-center justify-center text-xs">💖</div>
                        <div class="w-6 h-6 bg-gradient-to-br from-yellow-200 to-yellow-400 rounded-full pom-pom-bounce shadow-md flex items-center justify-center text-xs" style="animation-delay: 0.3s">✨</div>
                    </div>
                </div>
                <h1 class="text-4xl md:text-6xl font-extrabold mb-6">Let's get you set up! (◕‿◕)</h1>
                <p class="text-lg text-sky-800 mb-3">First, what should we call your fluffy cloud team?</p>

                <div class="max-w-xl mx-auto mb-2">
                    <div class="flex items-stretch gap-2">
                        <input id="team-name-input" type="text" class="flex-1 bg-white text-sky-800 px-6 py-4 rounded-xl text-xl text-center font-semibold focus:outline-none focus:ring-4 focus:ring-white/50 placeholder-sky-500" placeholder="Puffy Clouds" aria-label="Team name (press Enter to continue)">
                        <button id="shuffle-team-name-btn" class="bg-sky-500 hover:bg-sky-600 text-white px-4 rounded-xl shadow" title="Shuffle a team name" aria-label="Shuffle team name">🎲</button>
                    </div>
                    <div class="text-sm text-sky-900 mt-2">
                        Team link will be: <span class="bg-white px-2 py-1 rounded">pompom.io/<span id="team-link-slug">your-team</span></span>
                    </div>
                </div>

                <p class="text-lg text-sky-800 mb-3 mt-6">And what's your name?</p>
                <div class="max-w-xl mx-auto mb-6">
                    <div class="flex items-stretch gap-2">
                        <input id="user-name-setup-input" type="text" class="flex-1 bg-white text-sky-800 px-6 py-4 rounded-xl text-xl text-center font-semibold focus:outline-none focus:ring-4 focus:ring-white/50 placeholder-sky-500" placeholder="Soft Angel" aria-label="Your name (press Enter to continue)">
                        <button id="shuffle-user-name-btn" class="bg-sky-500 hover:bg-sky-600 text-white px-4 rounded-xl shadow" title="Shuffle a name" aria-label="Shuffle your name">🎲</button>
                    </div>
                    <p class="text-sm text-sky-900 mt-2">Looks good? You can edit or shuffle.</p>
                </div>

                <div class="max-w-xl mx-auto">
                    <button id="start-session-btn" class="w-full text-2xl px-8 py-5 rounded-2xl font-extrabold kawaii-button ghibli-glow text-sky-700 transition transform hover:-translate-y-1" aria-label="Start session">Start Session! (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧</button>
                    <p id="enter-hint" class="text-sm text-sky-900 mt-3">Press Enter to start</p>
                </div>
            </div>
        </div>

        <!-- Session Page -->
        <div id="session-page" class="hidden h-full w-full glassmorphism rounded-2xl shadow-lg flex">
            <!-- Sidebar -->
            <nav class="w-20 p-3 flex flex-col items-center justify-between border-r border-white/30 bg-white/10">
                <!-- User Profile Section -->
                <div class="text-center">
                    <div class="w-12 h-12 rounded-full bg-white flex items-center justify-center font-bold text-lg mb-2 mx-auto relative text-sky-600 cursor-pointer hover:scale-105 transition-transform" id="user-avatar" title="Click to edit name">
                        <!-- Cloud Pomeranian decorations -->
                        <div class="absolute -top-1 -right-1 w-4 h-4 bg-gradient-to-br from-blue-200 to-blue-400 rounded-full kawaii-float shadow-sm flex items-center justify-center text-xs">☁️</div>
                        <div class="absolute -bottom-1 -left-1 w-4 h-4 bg-gradient-to-br from-pink-200 to-pink-400 rounded-full kawaii-float shadow-sm flex items-center justify-center text-xs" style="animation-delay: 0.7s">💖</div>
                        <div class="absolute -top-1 -left-1 w-4 h-4 bg-gradient-to-br from-yellow-200 to-yellow-400 rounded-full kawaii-float shadow-sm flex items-center justify-center text-xs" style="animation-delay: 1.2s">✨</div>
                    </div>
                    <!-- Hidden input for name editing - will be shown in a modal when needed -->
                    <input type="text" id="user-name-input" class="hidden" readonly>
                </div>
                <!-- Main Navigation -->
                <div class="flex flex-col items-center space-y-1">
                    <!-- Primary Views -->
                    <div class="space-y-1 mb-3">
                        <div id="timer-view-btn" class="nav-btn nav-btn-primary active" title="Timer ⏱️">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/><path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/></svg>
                        </div>
                        <div id="planner-view-btn" class="nav-btn nav-btn-primary hidden" title="Planner 📋">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z"/></svg>
                        </div>
                    </div>

                    <!-- Divider -->
                    <div class="w-8 h-px bg-white/20 mb-3"></div>

                    <!-- Team Features -->
                    <div class="space-y-1 mb-3">
                        <div id="participants-view-btn" class="nav-btn nav-btn-secondary" title="Team 👥">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M15 14s1 0 1-1-1-4-6-4-6 3-6 4 1 1 1 1h10zm-9.995-.944v-.002.002zM3.022 13h9.956a.274.274 0 0 0 .014-.002l.008-.002c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10c-2.29 0-3.516.68-4.168 1.332-.678.678-.83 1.418-.832 1.664a1.05 1.05 0 0 0 .022.004zM8 7a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm3-2a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/></svg>
                        </div>
                        <div id="chat-view-btn" class="nav-btn nav-btn-secondary" title="Chat 💬">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M2.678 11.894a1 1 0 0 1 .287.801 10.97 10.97 0 0 1-.398 2c1.395-.323 2.247-.697 2.634-.893a1 1 0 0 1 .71-.074A8.06 8.06 0 0 0 8 14c3.996 0 7-2.506 7-5.5S11.996 3 8 3 1 5.506 1 8.5c0 1.468.617 2.83 1.678 3.894zm-.493 3.905a21.682 21.682 0 0 1-.713.129c-.2.032-.352-.176-.273-.362a9.68 9.68 0 0 0 .244-.637l.003-.01c.248-.72.45-1.548.524-2.319C.743 11.37 0 9.76 0 8.5 0 4.654 3.582 1 8 1s8 3.654 8 7.5-3.582 7.5-8 7.5c-1.259 0-2.44-.277-3.524-.764-.543-.266-1.13-.52-1.734-.823z"/></svg>
                        </div>
                        <div id="copy-link-btn" class="nav-btn nav-btn-secondary" title="Share Link 🔗">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/><path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/></svg>
                        </div>
                        <div id="calendar-event-btn" class="nav-btn nav-btn-secondary hidden" title="Calendar 📅">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5h16V4H0V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5z"/><path d="M11.5 6.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1z"/></svg>
                        </div>
                    </div>
                </div>
                <!-- Bottom Controls -->
                <div class="flex flex-col items-center space-y-2">
                    <div id="sound-toggle-btn" class="nav-btn nav-btn-utility" title="Sound 🔊">
                        <!-- Speaker icon will be injected here -->
                    </div>
                    <div id="settings-btn" class="nav-btn nav-btn-utility" title="Settings ⚙️">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.84-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l-.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5z"/></svg>
                    </div>
                    <div id="github-btn" class="nav-btn nav-btn-utility" title="View Source Code 📂">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
                    </div>
                    <div class="w-6 h-px bg-white/20 my-1"></div>
                    <div id="leave-btn" class="nav-btn nav-btn-danger" title="Leave Team 👋">
                       <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6 12.5a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v2a.5.5 0 0 1-1 0v-2A1.5 1.5 0 0 1 6.5 2h8A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-8A1.5 1.5 0 0 1 5 12.5v-2a.5.5 0 0 1 1 0v2z"/><path fill-rule="evenodd" d="M.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L1.707 7.5H10.5a.5.5 0 0 1 0 1H1.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/></svg>
                    </div>
                </div>
            </nav>

            <!-- Toast container -->
            <div id="toast" class="hidden fixed bottom-6 left-1/2 -translate-x-1/2 bg-sky-900 text-white px-4 py-2 rounded-lg shadow-lg text-sm z-[60]"></div>

            <!-- Main Content -->
            <main class="flex-1 flex flex-col p-4 md:p-8 overflow-hidden">
                <!-- All views here -->
                <div id="timer-view" class="flex-1 flex flex-col items-center justify-center">
                    <div class="relative">
                        <div id="timer-display" class="text-7xl md:text-9xl font-bold mb-4 relative z-10">25:00</div>
                        <!-- Studio Ghibli inspired floating elements -->
                        <div class="absolute -top-6 -right-6 w-12 h-12 bg-gradient-to-br from-blue-200 to-blue-400 rounded-full kawaii-float shadow-lg flex items-center justify-center">☁️</div>
                        <div class="absolute -top-6 -left-6 w-10 h-10 bg-gradient-to-br from-purple-200 to-purple-400 rounded-full kawaii-float shadow-lg flex items-center justify-center" style="animation-delay: 0.5s">💫</div>
                        <div class="absolute -bottom-6 -right-6 w-8 h-8 bg-gradient-to-br from-yellow-200 to-yellow-400 rounded-full kawaii-float shadow-lg flex items-center justify-center" style="animation-delay: 1s">✨</div>
                        <div class="absolute -bottom-6 -left-6 w-10 h-10 bg-gradient-to-br from-pink-200 to-pink-400 rounded-full kawaii-float shadow-lg flex items-center justify-center" style="animation-delay: 1.5s">💖</div>
                        <!-- Subtle background glow -->
                        <div class="absolute inset-0 bg-gradient-to-br from-sky-100/20 to-sky-200/20 rounded-3xl -z-10"></div>
                    </div>
                    <div id="timer-mode-display" class="text-xl text-sky-700 mb-4">Focus Time (25m) ☁️🐕☁️ ✨</div>
                    <!-- Current goal pill directly under timer -->
                    <div id="timer-goal-pill" class="hidden mb-6 px-6 py-3 bg-gradient-to-r from-sky-100 via-blue-50 to-purple-100 rounded-full text-sky-800 text-sm font-semibold shadow-lg border border-sky-200 kawaii-float">
                        <span class="text-sky-600 mr-2">🎯</span> <span id="timer-goal-text"></span>
                    </div>

                    <!-- Pomo Goal input -->
                    <div class="w-full max-w-xl mt-6">
                        <label class="block text-sm mb-2 text-sky-800 font-bold uppercase tracking-wide">🎯 Session Goal</label>
                        <div class="flex gap-3">
                            <input id="goal-input" type="text" placeholder="What will you accomplish this session?" class="flex-1 bg-white/95 text-sky-800 px-4 py-3 rounded-xl focus:outline-none focus:ring-2 focus:ring-sky-300 placeholder-sky-400 shadow-md border border-sky-200 font-medium">
                            <button id="save-goal-btn" class="btn btn-primary text-sm px-6 py-3 rounded-xl font-bold shadow-lg hover:shadow-xl transition-all hover:scale-105">Set Goal ✨</button>
                        </div>
                        <div id="current-goal" class="mt-3 text-sky-900 text-sm hidden font-semibold bg-sky-50/50 px-3 py-2 rounded-lg"></div>
                    </div>

                    <!-- Recent goal history -->
                    <div class="w-full max-w-xl mt-6">
                        <div class="text-xs text-sky-700 mb-3 font-bold uppercase tracking-wider">📈 Recent Goals</div>
                        <div id="goal-history" class="space-y-2 max-h-32 overflow-y-auto"></div>
                    </div>
                    <div class="flex items-center gap-4">
                        <button id="start-pause-btn" class="kawaii-button text-xl px-10 py-4 rounded-2xl font-bold text-sky-600 shadow-lg hover:shadow-xl transition-all hover:scale-105 bg-white/90 border-2 border-sky-200">Start ✨</button>
                        <button id="reset-btn" class="kawaii-button text-lg px-6 py-3 rounded-xl font-semibold text-sky-600 shadow-md hover:shadow-lg transition-all hover:scale-105 bg-white/70 border border-sky-200">Reset 🔄</button>
                    </div>
                    <p class="text-sm text-sky-700 mt-4 opacity-75 font-medium">Press spacebar to start/pause ⌨️✨</p>
                     <div id="mode-controls" class="mt-8">
                        <div class="mb-3"><span class="text-sm uppercase font-bold text-sky-700 tracking-wide">🎯 Focus Sessions</span></div>
                        <div class="flex items-center gap-2 mb-6">
                            <button data-mode="pomodoro25" class="mode-btn bg-white/15 hover:bg-white/25 px-4 py-2 rounded-xl text-sm font-semibold transition-all hover:scale-105 shadow-sm">25m</button>
                            <button data-mode="pomodoro30" class="mode-btn bg-white/15 hover:bg-white/25 px-4 py-2 rounded-xl text-sm font-semibold transition-all hover:scale-105 shadow-sm">30m</button>
                            <button data-mode="pomodoro45" class="mode-btn bg-white/15 hover:bg-white/25 px-4 py-2 rounded-xl text-sm font-semibold transition-all hover:scale-105 shadow-sm">45m</button>
                            <button data-mode="pomodoro60" class="mode-btn bg-white/15 hover:bg-white/25 px-4 py-2 rounded-xl text-sm font-semibold transition-all hover:scale-105 shadow-sm">60m</button>
                        </div>
                        <div class="mb-3"><span class="text-sm uppercase font-bold text-sky-700 tracking-wide">☁️ Break Time</span></div>
                        <div class="flex items-center gap-2">
                            <button data-mode="shortBreak" class="mode-btn bg-white/15 hover:bg-white/25 px-4 py-2 rounded-xl text-sm font-semibold transition-all hover:scale-105 shadow-sm">5m</button>
                            <button data-mode="longBreak" class="mode-btn bg-white/15 hover:bg-white/25 px-4 py-2 rounded-xl text-sm font-semibold transition-all hover:scale-105 shadow-sm">15m</button>
                        </div>
                    </div>
                </div>
                <div id="planner-view" class="hidden flex-1 flex flex-col">
                    <h2 class="text-3xl font-bold mb-6">Day Planner</h2>
                    <div class="mb-6 p-4 glassmorphism rounded-lg">
                        <h3 class="font-semibold mb-2">Schedule New Pomodoro</h3>
                        <div class="flex flex-wrap gap-4 items-end">
                            <div class="flex-grow"><label for="schedule-time" class="text-sm">Time</label><input id="schedule-time" type="time" class="w-full bg-white/20 p-2 rounded-md focus:outline-none"></div>
                            <div class="flex-grow-[3]"><label for="schedule-desc" class="text-sm">Description</label><input id="schedule-desc" type="text" placeholder="e.g., Team Sync" class="w-full bg-white/20 p-2 rounded-md focus:outline-none placeholder-white/50"></div>
                            <button id="schedule-add-btn" class="btn btn-primary">Schedule</button>
                        </div>
                        <div class="mt-3 flex flex-wrap gap-2">
                            <button id="calendar-create-btn" class="btn btn-secondary">Create Google Calendar Event</button>
                            <button id="meet-now-btn" class="btn btn-secondary">Start a Google Meet</button>
                        </div>
                    </div>
                    <div class="mb-6 p-4 glassmorphism rounded-lg">
                        <h3 class="font-semibold mb-3">Team Todos (AI assisted)</h3>
                        <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-end mb-3">
                            <div class="md:col-span-4">
                                <label for="todo-idea-input" class="text-sm">Task idea</label>
                                <input id="todo-idea-input" type="text" placeholder="e.g., Draft weekly update" class="w-full bg-white/20 p-2 rounded-md focus:outline-none placeholder-white/50" aria-label="Task idea (press Enter to add)">
                            </div>
                            <div class="flex gap-2 md:col-span-1">
                                <button id="todo-add-btn" class="btn btn-primary w-full" title="Add (AI will set owner & due)">Add</button>
                            </div>
                        </div>
                        <div class="text-xs text-sky-700 mb-2">Owner and due date are picked automatically by AI. You can reorder and edit the task text later.</div>
                        <div id="todo-status" class="text-sm text-sky-800"></div>
                    </div>
                    <div id="todo-list" class="flex-1 overflow-y-auto space-y-2 pr-2"></div>
                    <div id="planner-list" class="flex-1 overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <div id="participants-view" class="hidden flex-1 flex flex-col"><h2 class="text-3xl font-bold mb-6">Fluffy Friends ☁️ (<span id="participant-count">0</span>)</h2><div id="participants-list" class="flex-1 overflow-y-auto space-y-2"></div></div>
                <div id="chat-view" class="hidden flex-1 flex flex-col h-full"><h2 class="text-3xl font-bold mb-4">Chat ☁️💬</h2><div id="chat-messages" class="flex-1 overflow-y-auto mb-4 p-4 bg-black/10 rounded-lg"></div><div class="flex gap-2"><input id="chat-input" type="text" placeholder="Type a fluffy message... (◕‿◕)" class="w-full bg-white text-sky-800 px-4 py-2 rounded-lg focus:outline-none placeholder-sky-400"><button id="send-chat-btn" class="btn btn-primary">Send ✨</button></div></div>
            </main>
        </div>

        <!-- End of Session Modal -->
        <div id="end-session-modal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div class="glassmorphism p-8 rounded-2xl shadow-lg text-center max-w-sm w-full">
                <h2 id="end-session-title" class="text-3xl font-bold mb-4">Focus Time Over!</h2>
                <p id="end-session-message" class="text-lg mb-6">Time for a short break.</p>
                <button id="end-session-dismiss-btn" class="btn btn-primary">Dismiss</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="hidden fixed inset-0 bg-black/50 items-center justify-center z-50">
        <div class="glassmorphism p-6 rounded-2xl shadow-lg max-w-md w-full mx-4">
            <div class="flex items-center justify-between mb-6">
                <h3 class="text-2xl font-bold text-sky-900">⚙️ Settings</h3>
                <button id="close-settings-btn" class="text-sky-800 hover:text-sky-900 text-3xl font-light transition-colors">&times;</button>
            </div>
            <div class="space-y-5">
                <!-- Advanced Features Toggle -->
                <div class="p-4 bg-gradient-to-r from-sky-50/50 to-blue-50/50 rounded-lg border border-sky-200/30">
                    <label class="flex items-center gap-3 text-sm font-medium cursor-pointer">
                        <input id="feature-mode-toggle" type="checkbox" class="w-4 h-4 text-sky-600 rounded focus:ring-sky-500">
                        <span class="text-sky-900">Enable advanced features</span>
                    </label>
                    <div class="text-xs text-sky-700 mt-2 ml-7" id="feature-mode-status">Todos + Planner + Calendar</div>
                </div>

                <!-- AI Features Section (only shown when advanced features are enabled) -->
                <div id="ai-features-section" class="hidden">
                    <div class="p-4 bg-gradient-to-r from-green-50/50 to-emerald-50/50 rounded-lg border border-green-200/30">
                        <div class="flex items-center gap-2 mb-3">
                            <span class="text-green-500 text-lg">✨</span>
                            <span class="font-semibold text-sky-900">AI Features</span>
                            <span class="text-xs text-green-600 bg-green-100/50 px-2 py-1 rounded-full">Powered by Groq</span>
                        </div>
                        <div class="text-sm text-sky-700 mb-3">
                            AI features are provided through a shared Groq API key managed by the server.
                            No setup required - just use the AI features in Todos and Planner!
                        </div>
                        <div id="ai-status-section" class="p-3 bg-white/30 rounded-md text-sm space-y-1">
                            <div class="flex justify-between items-center">
                                <span class="text-sky-800">Server AI:</span>
                                <span id="api-key-status-text" class="font-semibold text-sky-900">Checking...</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sky-800">AI Features:</span>
                                <span id="ai-features-status" class="font-semibold text-sky-900">Checking...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- User Name Edit Modal -->
    <div id="user-name-modal" class="hidden fixed inset-0 bg-black/50 items-center justify-center z-50">
        <div class="glassmorphism p-6 rounded-2xl shadow-lg max-w-sm w-full mx-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-xl font-bold text-sky-900">👤 Edit Name</h3>
                <button id="close-user-name-modal" class="text-sky-800 hover:text-sky-900 text-2xl font-light transition-colors">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="user-name-modal-input" class="block text-sm font-medium text-sky-800 mb-2">Your name</label>
                    <input type="text" id="user-name-modal-input" class="w-full bg-white/20 border border-white/30 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent text-sky-900" placeholder="Enter your name">
                </div>
                <div class="flex gap-2 justify-end">
                    <button id="cancel-user-name" class="btn btn-secondary px-4 py-2">Cancel</button>
                    <button id="save-user-name" class="btn btn-primary px-4 py-2">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
      // Pre-module error capture so parse errors in module still get recorded
      (function(){
        try {
          window.__CONSOLE_LOGS = window.__CONSOLE_LOGS || [];
          window.__GET_TEST_CONSOLE__ = () => (window.__CONSOLE_LOGS || []).slice();
          window.addEventListener('error', (e) => {
            try { window.__CONSOLE_LOGS.push({ level: 'error', message: e.message || 'window.error pre-module' }); } catch {}
          });
          window.addEventListener('unhandledrejection', (e) => {
            try { window.__CONSOLE_LOGS.push({ level: 'error', message: (e.reason && (e.reason.message || String(e.reason))) || 'unhandledrejection pre-module' }); } catch {}
          });
        } catch {}
      })();
    </script>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";

	        // --- Test console capture (harmless in production) ---
	        try {
	            window.__CONSOLE_LOGS = window.__CONSOLE_LOGS || [];
	            const __wrap = (level) => {
	                const orig = console[level].bind(console);
	                console[level] = (...args) => {
	                    try { window.__CONSOLE_LOGS.push({ level, message: args.map(a => String(a)).join(' ') }); } catch {}
	                    return orig(...args);
	                };
	            };
	            __wrap('error');
	            __wrap('warn');
	            window.addEventListener('error', (e) => {
	                try { window.__CONSOLE_LOGS.push({ level: 'error', message: e.message || 'window.onerror' }); } catch {}
	            });
	            window.addEventListener('unhandledrejection', (e) => {
	                try { window.__CONSOLE_LOGS.push({ level: 'error', message: (e.reason && (e.reason.message || String(e.reason))) || 'unhandledrejection' }); } catch {}
	            });
	            window.__GET_TEST_CONSOLE__ = () => (window.__CONSOLE_LOGS || []).slice();
	        } catch {}

        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, serverTimestamp, updateDoc, deleteDoc, setLogLevel, query, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM ELEMENTS ---
        const landingPage = document.getElementById('landing-page');
        const nameInputPage = document.getElementById('name-input-page');
        const sessionPage = document.getElementById('session-page');
        const sessionNameInput = document.getElementById('session-name-input');
        const createSessionBtn = document.getElementById('create-session-btn');
        const teamNameInput = document.getElementById('team-name-input');
        const userNameSetupInput = document.getElementById('user-name-setup-input');
    const shuffleTeamNameBtn = document.getElementById('shuffle-team-name-btn');
    const shuffleUserNameBtn = document.getElementById('shuffle-user-name-btn');
    const teamLinkSlug = document.getElementById('team-link-slug');
        const startSessionBtn = document.getElementById('start-session-btn');
        const enterHint = document.getElementById('enter-hint');
        const userNameInput = document.getElementById('user-name-input');
        const userAvatar = document.getElementById('user-avatar');
        const timerDisplay = document.getElementById('timer-display');
        const timerModeDisplay = document.getElementById('timer-mode-display');
        const startPauseBtn = document.getElementById('start-pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const modeControls = document.getElementById('mode-controls');
        const participantsList = document.getElementById('participants-list');
    // Routing mode: use hash-only routing to avoid 404s on refresh with static servers
    const USE_HASH_ROUTING = true;
        const participantCount = document.getElementById('participant-count');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
    // Goal UI elements
    const goalInput = document.getElementById('goal-input');
    const saveGoalBtn = document.getElementById('save-goal-btn');
    const currentGoalEl = document.getElementById('current-goal');
    const timerGoalPill = document.getElementById('timer-goal-pill');
    const timerGoalText = document.getElementById('timer-goal-text');
    const goalHistoryEl = document.getElementById('goal-history');
    const viewTimerBtn = document.getElementById('timer-view-btn');
        const viewPlannerBtn = document.getElementById('planner-view-btn');
        const viewParticipantsBtn = document.getElementById('participants-view-btn');
        const viewChatBtn = document.getElementById('chat-view-btn');
        const calendarEventBtn = document.getElementById('calendar-event-btn');
    const copyLinkBtn = document.getElementById('copy-link-btn');
    const copyLinkBtnInline = document.getElementById('copy-link-btn-inline');
    const githubBtn = document.getElementById('github-btn');
        const leaveBtn = document.getElementById('leave-btn');
        const soundToggleBtn = document.getElementById('sound-toggle-btn');
    const testAlarmBtn = document.getElementById('test-alarm-btn');
        const timerView = document.getElementById('timer-view');
        const plannerView = document.getElementById('planner-view');
        // Ensure advanced buttons are hidden by default (basic mode)
        try {
            if (viewPlannerBtn) viewPlannerBtn.classList.add('hidden');
            if (calendarEventBtn) calendarEventBtn.classList.add('hidden');
        } catch {}
        const participantsView = document.getElementById('participants-view');
        const chatView = document.getElementById('chat-view');
        const scheduleTimeInput = document.getElementById('schedule-time');
        const scheduleDescInput = document.getElementById('schedule-desc');
        const scheduleAddBtn = document.getElementById('schedule-add-btn');
        const calendarCreateBtn = document.getElementById('calendar-create-btn');
        const meetNowBtn = document.getElementById('meet-now-btn');
        const plannerList = document.getElementById('planner-list');
    const toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
        const endSessionModal = document.getElementById('end-session-modal');
    const basicModeBtn = document.getElementById('basic-mode-btn');
    const featureModeToggle = document.getElementById('feature-mode-toggle');
    const advancedModeBtn = document.getElementById('advanced-mode-btn');
        const endSessionTitle = document.getElementById('end-session-title');
        const endSessionMessage = document.getElementById('end-session-message');
        const endSessionDismissBtn = document.getElementById('end-session-dismiss-btn');
    // Settings modal elements
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsBtn = document.getElementById('close-settings-btn');
    const apiKeyInput = document.getElementById('api-key-input');
    const saveApiKeyBtn = document.getElementById('save-api-key-btn');
    const clearApiKeyBtn = document.getElementById('clear-api-key-btn');
    const apiKeyStatusText = document.getElementById('api-key-status-text');
    const aiFeaturesStatus = document.getElementById('ai-features-status');
    const aiFeaturesSection = document.getElementById('ai-features-section');
    const openGroqConsoleBtn = document.getElementById('open-groq-console-btn');
    // User name modal elements
    const userNameModal = document.getElementById('user-name-modal');
    const closeUserNameModal = document.getElementById('close-user-name-modal');
    const userNameModalInput = document.getElementById('user-name-modal-input');
    const cancelUserName = document.getElementById('cancel-user-name');
    const saveUserName = document.getElementById('save-user-name');
    const toastEl = document.getElementById('toast');
    // Toast utility available app-wide
    function showToast(msg, ms = 1600) {
        const el = toastEl || document.getElementById('toast');
        if (!el) return;
        el.textContent = msg;
        el.classList.remove('hidden');
        clearTimeout(el._t);
        el._t = setTimeout(() => el.classList.add('hidden'), ms);
    }
    // Todos UI
    const todoIdeaInput = document.getElementById('todo-idea-input');
    const todoAddBtn = document.getElementById('todo-add-btn');
    const todoList = document.getElementById('todo-list');
    const todoStatus = document.getElementById('todo-status');

        // --- FIREBASE & APP STATE ---
    const firebaseConfig = (typeof window !== 'undefined' && window.__firebase_config) ? JSON.parse(window.__firebase_config) : {};
    const appId = (typeof window !== 'undefined' && window.__app_id) ? window.__app_id : 'pompom-default';
    const hasFirebaseConfig = firebaseConfig && typeof firebaseConfig.apiKey === 'string' && firebaseConfig.apiKey.length > 0;
    // Allow forcing offline mode via URL param for tests: ?offline=1
    const urlParams = new URLSearchParams(location.search);
    let OFFLINE_MODE = urlParams.get('offline') === '1' ? true : !hasFirebaseConfig;

        let app, auth, db;
        let userId, userName;
        let sessionId;
    let sessionUnsubscribe, participantsUnsubscribe, chatUnsubscribe, plannerUnsubscribe, todosUnsubscribe;
        let timerInterval, alarmCheckInterval;
        let audioCtx;
        let scheduledEvents = [];
        let lastCheckedMinute = -1;
    let isSoundEnabled = localStorage.getItem('pompom_sound_enabled') === 'true';
        // --- Goal storage helpers ---
        function goalStorageKey() {
            return `pompom_goals_${sessionId || 'default'}`;
        }
        function loadGoals() {
            try {
                const raw = localStorage.getItem(goalStorageKey());
                return raw ? JSON.parse(raw) : [];
            } catch { return []; }
        }
        function saveGoals(list) {
            try { localStorage.setItem(goalStorageKey(), JSON.stringify(list)); } catch {}
        }
        function renderGoals() {
            const list = loadGoals();
            goalHistoryEl.innerHTML = '';
            list.slice().reverse().slice(0, 5).forEach(item => {
                const row = document.createElement('div');
                row.className = 'flex items-center justify-between bg-white/20 rounded-lg px-4 py-3 text-sm shadow-sm border border-white/30 backdrop-blur-sm';
                const status = { success: '✅', partial: '🟡', failed: '❌' }[item.status] || '⏺️';
                const carried = item.carried ? ' 🔄' : '';
                row.innerHTML = `<span class="truncate max-w-[70%] font-medium text-sky-900">${item.text}</span><span class="ml-3 text-lg">${status}${carried}</span>`;
                goalHistoryEl.appendChild(row);
            });
            const current = list.find(g => g.status === 'active');
            if (current && currentGoalEl) {
                currentGoalEl.classList.remove('hidden');
                currentGoalEl.textContent = `Current goal: ${current.text}`;
            } else if (currentGoalEl) {
                currentGoalEl.classList.add('hidden');
                currentGoalEl.textContent = '';
            }
            // Update timer pill
            if (current && timerGoalPill && timerGoalText) {
                timerGoalPill.classList.remove('hidden');
                timerGoalText.textContent = current.text;
            } else if (timerGoalPill) {
                timerGoalPill.classList.add('hidden');
            }
        }
    let localTodos = [];
    let currentTodos = [];
    // Map of participant name -> IANA time zone
    let participantsTZByName = {};
    let nextTodoOrder = 0;
    // Prevent list re-render while editing a todo inline
    let isEditingTodo = false;
    // Subtask drag state
    let draggingSubtask = null; // { parentId, sid }

        // Local-only state when offline (no Firebase configured)
        let localSessionState = {
            mode: 'pomodoro25',
            lastFocusMode: 'pomodoro25',
            duration: 25 * 60,
            isRunning: false,
            startTime: null // epoch ms
        };
            // Goals: re-render after routing determines sessionId
            try { renderGoals(); } catch {}
        let localChat = [];

        const TIMER_MODES = {
            pomodoro25: { duration: 25 * 60, label: 'Focus Time (25m) ☁️✨', type: 'focus' },
            pomodoro30: { duration: 30 * 60, label: 'Focus Time (30m) ☁️✨', type: 'focus' },
            pomodoro45: { duration: 45 * 60, label: 'Focus Time (45m) ☁️✨', type: 'focus' },
            pomodoro60: { duration: 60 * 60, label: 'Focus Time (60m) ☁️✨', type: 'focus' },
            shortBreak: { duration: 5 * 60, label: 'Short Break (5m) 💤💖', type: 'break' },
            longBreak: { duration: 15 * 60, label: 'Long Break (15m) 💤💖', type: 'break' },
        };

        // --- INITIALIZATION ---
    function init() {
            try {
                if (!OFFLINE_MODE) {
                    app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getFirestore(app);
                    // Reduce noisy Firestore logs by default; enable with ?fsdebug=1
                    setLogLevel(urlParams.get('fsdebug') === '1' ? 'debug' : 'error');
                } else {
                    console.warn('PomPom running in offline mode: No Firebase config provided. Features like sync, chat, and participants are disabled.');
                }
            } catch (e) {
                console.error("Firebase initialization failed.", e);
                OFFLINE_MODE = true;
            }
            // Ensure Basic UI is the default for everyone (one-time migration)
            try {
                const v = localStorage.getItem('pompom_feature_mode_v') || '1';
                if (v !== '2') {
                    localStorage.setItem('pompom_feature_mode', 'basic');
                    localStorage.setItem('pompom_feature_mode_v', '2');
                }
            } catch {}
            // Default sound ON for first-time users
            if (localStorage.getItem('pompom_sound_enabled') === null) {
                isSoundEnabled = true;
                localStorage.setItem('pompom_sound_enabled', 'true');
            }
            updateSoundUI();
            // Initialize settings status once so the modal shows accurate info
            try { updateSettingsStatusUI(); } catch {}
            try { applyAdvancedVisibility(); } catch {}
            if (!OFFLINE_MODE) handleAuthentication();
            handleRouting();
            setupEventListeners();
            validateStartCta();
            // If landing directly on session page in offline mode, ensure timer UI renders once
            if (OFFLINE_MODE) renderTimerFromLocalState();
            // Enable drag-to-promote subtasks
            try { enableSubtaskPromoteViaDrag(); } catch {}
        }

        async function handleAuthentication() {
            if (OFFLINE_MODE) return;
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    try { applyAdvancedVisibility(); } catch {}
                    if (sessionId) await joinSession();
                } else {
                    try {
                        if (typeof window !== 'undefined' && window.__initial_auth_token) {
                            await signInWithCustomToken(auth, window.__initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) { console.error("Authentication failed:", error); }
                    finally { try { applyAdvancedVisibility(); } catch {} }
                }
            });
        }

    function handleRouting() {
            // Prefer hash-based routing to avoid 404s on static refresh
            let potentialSessionId = '';
            const hash = window.location.hash || '';
            if (hash.startsWith('#/')) {
                const seg = hash.slice(2).split('/').filter(Boolean);
                potentialSessionId = seg[seg.length - 1] || '';
            } else if (!USE_HASH_ROUTING) {
                const segments = window.location.pathname.split('/').filter(s => s);
                potentialSessionId = segments.pop() || '';
            }
            if (potentialSessionId) {
                sessionId = potentialSessionId;
        // Show name input page first, prefilling from storage when available
        showNameInputPage();
        const storedTeam = getTeamNameFromStorage();
        const storedUser = localStorage.getItem('pompom_username');
        teamNameInput.value = storedTeam || sessionId;
        userNameSetupInput.value = storedUser || generateRandomUserName();
        updateTeamLinkPreview();
        validateStartCta();
            } else {
                showLandingPage();
        // Prefill landing input with stored team name if available
        const storedTeam = getTeamNameFromStorage();
        if (storedTeam) sessionNameInput.value = storedTeam;
            }
        }

        // --- UI MANAGEMENT ---
        function showLandingPage() {
            landingPage.classList.remove('hidden');
            nameInputPage.classList.add('hidden');
            sessionPage.classList.add('hidden');
        }
        function showNameInputPage() {
            landingPage.classList.add('hidden');
            nameInputPage.classList.remove('hidden');
            sessionPage.classList.add('hidden');
        }
        function showSessionPage() {
            sessionPage.classList.remove('hidden');
            sessionPage.classList.add('flex');
            landingPage.classList.add('hidden');
            nameInputPage.classList.add('hidden');
        }

        function switchView(view) {
            [timerView, plannerView, participantsView, chatView].forEach(v => v.classList.add('hidden'));
            [viewTimerBtn, viewPlannerBtn, viewParticipantsBtn, viewChatBtn].forEach(b => b.classList.remove('active'));
            const viewMap = { timer: { view: timerView, btn: viewTimerBtn }, planner: { view: plannerView, btn: viewPlannerBtn }, participants: { view: participantsView, btn: viewParticipantsBtn }, chat: { view: chatView, btn: viewChatBtn } };
            if (viewMap[view]) { viewMap[view].view.classList.remove('hidden'); viewMap[view].btn.classList.add('active'); }
        }

        function showEndOfSessionModal(mode, lastFocusMode) {
            const currentModeInfo = TIMER_MODES[mode];
            const nextModeKey = currentModeInfo.type === 'focus' ? 'shortBreak' : lastFocusMode;
            const nextModeInfo = TIMER_MODES[nextModeKey];

            endSessionTitle.textContent = `${currentModeInfo.label} Over! ✨`;
            endSessionMessage.textContent = `Time for a ${nextModeInfo.label.toLowerCase()} (◕‿◕)♡`;
            endSessionModal.classList.remove('hidden');
            playAlarm();
        }

        function updateActiveModeButton(activeMode) {
            document.querySelectorAll('#mode-controls .mode-btn').forEach(btn => {
                if (btn.dataset.mode === activeMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            // Share link copy utility (supports hash routing; includes fallback)
            async function copyShareLink() {
                try {
                    const base = location.origin;
                    const slug = toSlug(sessionId || teamNameInput?.value || 'session');
                    const url = USE_HASH_ROUTING ? `${base}/#/${slug}` : `${base}/${slug}`;
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(url);
                    } else {
                        // Fallback for insecure context or denied permission
                        const ta = document.createElement('textarea');
                        ta.value = url;
                        ta.setAttribute('readonly', '');
                        ta.style.position = 'absolute';
                        ta.style.left = '-9999px';
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                    }
                    showToast('Link copied');
                } catch (e) {
                    console.error('Copy link failed', e);
                    showToast('Copy failed');
                }
            }
            // Sync Advanced features toggle from saved state and wire change handler
            try {
                if (featureModeToggle) {
                    // Ensure a default exists; default to basic (off)
                    if (!localStorage.getItem('pompom_feature_mode')) {
                        try { localStorage.setItem('pompom_feature_mode', 'basic'); } catch {}
                    }
                    featureModeToggle.checked = getUserFeatureToggleOn();
                    featureModeToggle.addEventListener('change', (e) => {
                        try { localStorage.setItem('pompom_feature_mode', e.target.checked ? 'advanced' : 'basic'); } catch {}
                        applyAdvancedVisibility();
                    });
                }
            } catch {}
            createSessionBtn.addEventListener('click', () => {
                let name = sessionNameInput.value.trim().replace(/[^a-zA-Z0-9-]/g, '');
                if (!name) {
                    name = generateRandomTeamName();
                }
                try { localStorage.setItem('pompom_team_name', toSlug(name)); } catch {}
                // Update both path and hash for static hosting
                if (!USE_HASH_ROUTING) {

                    try { window.history.pushState({}, name, `/${name}`); } catch {}

                }
                window.location.hash = `#/${name}`;
                handleRouting();
            });
            sessionNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    createSessionBtn.click();
                }
            });

            startSessionBtn.addEventListener('click', () => {
                // Get the team name and user name from the inputs
                const teamName = teamNameInput.value.trim() || generateRandomTeamName();
                const userNameValue = userNameSetupInput.value.trim() || generateRandomUserName();

                // Update the session ID if team name was changed
                if (teamName !== sessionId) {
                    sessionId = toSlug(teamName);
                    if (!USE_HASH_ROUTING) { try { window.history.pushState({}, sessionId, `/${sessionId}`); } catch {} }
                    window.location.hash = `#/${sessionId}`;
                }

                // Store the user name
                userName = userNameValue;
                localStorage.setItem('pompom_username', userName);
                try { localStorage.setItem('pompom_team_name', toSlug(teamName)); } catch {}

                // Initialize and show session page
                updateUserNameUI();
                initAudioAndNotifications();
                showSessionPage();
                if (OFFLINE_MODE) {
                    // Basic offline setup
                    updateParticipantsOffline();
                    renderTimerFromLocalState();
                    if (alarmCheckInterval) clearInterval(alarmCheckInterval);
                    alarmCheckInterval = setInterval(checkAlarms, 1000);
                } else if (userId) {
                    joinSession();
                }
            });

            // Allow pressing Enter to start
            teamNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    startSessionBtn.click();
                }
            });
            userNameSetupInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    startSessionBtn.click();
                }
            });
            teamNameInput.addEventListener('input', () => {
                updateTeamLinkPreview();
                validateStartCta();
                try { localStorage.setItem('pompom_team_name', toSlug(teamNameInput.value || '')); } catch {}
            });
            userNameSetupInput.addEventListener('input', () => {
                validateStartCta();
                try { localStorage.setItem('pompom_username', userNameSetupInput.value || ''); } catch {}
            });
            // Shuffle buttons
            shuffleTeamNameBtn.addEventListener('click', () => { teamNameInput.value = generateRandomTeamName().replace('-', ' '); updateTeamLinkPreview(); validateStartCta(); teamNameInput.focus(); });
            shuffleUserNameBtn.addEventListener('click', () => { userNameSetupInput.value = generateRandomUserName(); userNameSetupInput.focus(); });
            // Live link preview handled above with validation

            // User avatar click to open name edit modal
            userAvatar.addEventListener('click', () => {
                userNameModalInput.value = userName || '';
                userNameModal.classList.remove('hidden');
                userNameModal.classList.add('flex');
                userNameModalInput.focus();
                userNameModalInput.select();
            });

            // User name modal handlers
            closeUserNameModal.addEventListener('click', () => {
                userNameModal.classList.add('hidden');
                userNameModal.classList.remove('flex');
            });

            cancelUserName.addEventListener('click', () => {
                userNameModal.classList.add('hidden');
                userNameModal.classList.remove('flex');
            });

            saveUserName.addEventListener('click', () => {
                const newName = userNameModalInput.value.trim();
                if (newName) {
                    userName = newName;
                    updateUserDisplay();
                    updateName();
                }
                userNameModal.classList.add('hidden');
                userNameModal.classList.remove('flex');
            });

            userNameModalInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveUserName.click();
                } else if (e.key === 'Escape') {
                    cancelUserName.click();
                }
            });

            startPauseBtn.addEventListener('click', toggleTimer);
            resetBtn.addEventListener('click', resetTimer);

            modeControls.addEventListener('click', (e) => {
                if (e.target.matches('.mode-btn')) {
                    const mode = e.target.dataset.mode;
                    setMode(mode);
                }
            });

            // Bind share link buttons
            if (copyLinkBtn) copyLinkBtn.addEventListener('click', copyShareLink);
            if (copyLinkBtnInline) copyLinkBtnInline.addEventListener('click', copyShareLink);

            // Goal handlers
            if (saveGoalBtn) saveGoalBtn.addEventListener('click', async () => {
                const text = (goalInput?.value || '').trim();
                if (!text) { showToast('Enter a goal'); return; }
                if (OFFLINE_MODE) {
                    const list = loadGoals();
                    list.forEach(g => { if (g.status === 'active') g.status = 'partial'; });
                    list.push({ id: Date.now(), text, status: 'active', startedAt: Date.now() });
                    saveGoals(list);
                    renderGoals();
                } else {
                    try {
                        // Close any active goals
                        const existingSnap = await getDocs(getGoalsRef());
                        existingSnap.forEach(async d => {
                            const data = d.data();
                            if (data.status === 'active') await updateDoc(doc(getGoalsRef(), d.id), { status: 'partial' });
                        });
                        await addDoc(getGoalsRef(), { text, status: 'active', startedAt: serverTimestamp(), createdBy: userName || getUserNameFromStorage() });
                    } catch (e) { console.error('Failed to save goal', e); }
                }
                goalInput.value = '';
                renderGoals();
                // Auto-post to chat
                const chatMsg = `🎯 Goal set: ${text}`;
                if (OFFLINE_MODE) {
                    localChat.push({ userId: 'local', userName: userName || getUserNameFromStorage(), text: chatMsg, createdAt: new Date() });
                    renderLocalChat();
                } else {
                    try {
                        await addDoc(getChatRef(), { userId, userName: userName || getUserNameFromStorage(), text: chatMsg, createdAt: serverTimestamp() });
                    } catch (e) { console.warn('Failed to post goal to chat', e); }
                }
            });
            if (goalInput) goalInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveGoalBtn.click();
                    // Start timer after brief delay to allow goal save
                    setTimeout(() => {
                        if (startPauseBtn && startPauseBtn.textContent.includes('Start')) {
                            startPauseBtn.click();
                        }
                    }, 100);
                }
            });

            viewTimerBtn.addEventListener('click', () => switchView('timer'));
            viewPlannerBtn.addEventListener('click', () => switchView('planner'));
            viewParticipantsBtn.addEventListener('click', () => switchView('participants'));
            viewChatBtn.addEventListener('click', () => switchView('chat'));

            scheduleAddBtn.addEventListener('click', scheduleNewPomodoro);
            scheduleDescInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') scheduleNewPomodoro(); });
            // Planner: Google Calendar + Meet
            calendarCreateBtn.addEventListener('click', () => {
                const title = encodeURIComponent(scheduleDescInput.value.trim() || 'PomPom Focus Session');
                // Build start/end from today + selected time; default 30m
                const now = new Date();
                const [hh, mm] = (scheduleTimeInput.value || '00:00').split(':');
                const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), parseInt(hh||'0',10), parseInt(mm||'0',10), 0);
                const end = new Date(start.getTime() + 30*60*1000);
                const fmt = (d) => `${d.getUTCFullYear()}${String(d.getUTCMonth()+1).padStart(2,'0')}${String(d.getUTCDate()).padStart(2,'0')}T${String(d.getUTCHours()).padStart(2,'0')}${String(d.getUTCMinutes()).padStart(2,'0')}00Z`;
                const dates = `${fmt(start)}/${fmt(end)}`;
                const details = encodeURIComponent('Created by PomPom');
                const url = `https://calendar.google.com/calendar/u/0/r/eventedit?text=${title}&dates=${dates}&details=${details}`;
                window.open(url, '_blank');
            });
            meetNowBtn.addEventListener('click', () => {
                // Open a new Google Meet (anonymous users will get prompted to start a meeting if permitted)
                window.open('https://meet.google.com/new', '_blank');
            });
            calendarEventBtn.addEventListener('click', handleCreateCalendarEvent);
            sendChatBtn.addEventListener('click', sendChatMessage);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendChatMessage(); });

            soundToggleBtn.addEventListener('click', toggleSound);
            if (testAlarmBtn) {
                testAlarmBtn.addEventListener('click', () => {
                    initAudioAndNotifications();
                    playAlarm();
                    showNotification({ description: 'Test alarm' });
                });
            }
            endSessionDismissBtn.addEventListener('click', () => endSessionModal.classList.add('hidden'));

            leaveBtn.addEventListener('click', async () => {
                // Confirm before leaving
                if (confirm('Are you sure you want to leave this fluffy cloud team? ☁️💔')) {
                    try {
                        // Clean up timers and listeners
                        clearInterval(timerInterval);
                        clearInterval(alarmCheckInterval);

                        // Remove user from session if online
                        // remove subtask from local
                        const tIdx = localTodos.findIndex(x => (x.id || String(x.createdAt)) === parentId);
                        if (tIdx >= 0) {
                            localTodos[tIdx].subtasks = (localTodos[tIdx].subtasks || []).filter(st => (st.id || '') !== s.id);
                        }
                        if (!OFFLINE_MODE && userId) {
                            const userRef = getUserRef(userId);
                            await deleteDoc(userRef);
                        if (s.id) {
                            await deleteDoc(doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', parentId, 'subtasks', s.id));
                        }
                        }

                        // Clear local storage
                        localStorage.removeItem('sessionId');
                        localStorage.removeItem('userId');

                        // Return to landing page
                // DnD events for subtasks
                row.addEventListener('dragstart', (e) => {
                    draggingSubtask = { parentId, sid: row.dataset.sid };
                    row.classList.add('opacity-70');
                });
                row.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; });
                row.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    if (!draggingSubtask || draggingSubtask.parentId !== parentId) return;
                    const rows = Array.from(container.children);
                    const fromIdx = rows.findIndex(r => r.dataset.sid === draggingSubtask.sid);
                    const toIdx = rows.findIndex(r => r === row);
                    if (fromIdx < 0 || toIdx < 0 || fromIdx === toIdx) return;
                    const arr = rows.slice();
                    const [moved] = arr.splice(fromIdx, 1);
                    arr.splice(toIdx, 0, moved);
                    // Reassign order based on new DOM order
                    for (let i = 0; i < arr.length; i++) {
                        const sid = arr[i].dataset.sid;
                        if (OFFLINE_MODE) {
                            const tIdx = localTodos.findIndex(x => (x.id || String(x.createdAt)) === parentId);
                            if (tIdx >= 0) {
                                const subs = localTodos[tIdx].subtasks || [];
                                const sub = subs.find(st => (st.id || `${parentId}::`) === sid || (st.id ? st.id : `${parentId}::${subs.indexOf(st)}`) === sid);
                                if (sub) sub.order = i;
                            }
                        } else {
                            // Persist to Firestore if we have real IDs
                            const real = items.find(x => (x.id || `${parentId}::`) === sid);
                            if (real && real.id) {
                                await updateDoc(doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', parentId, 'subtasks', real.id), { order: i });
                            }
                        }
                    }
                    // Rerender
                    if (OFFLINE_MODE) renderTodosLocal();
                });
                row.addEventListener('dragend', () => { row.classList.remove('opacity-70'); draggingSubtask = null; });
                        window.location.href = '/';
                    } catch (error) {
                        console.error('Error leaving session:', error);
                        // Still navigate away even if cleanup fails

        // Allow promoting by dragging a subtask to the main list container
        function enableSubtaskPromoteViaDrag() {
            if (!todoList) return;
            todoList.addEventListener('dragover', (e) => {
                if (draggingSubtask) e.preventDefault();
            });
            todoList.addEventListener('drop', async (e) => {
                if (!draggingSubtask) return;
                e.preventDefault();
                const { parentId, sid } = draggingSubtask;
                draggingSubtask = null;
                // Find subtask data
                if (OFFLINE_MODE) {
                    const tIdx = localTodos.findIndex(x => (x.id || String(x.createdAt)) === parentId);
                    if (tIdx >= 0) {
                        const subs = localTodos[tIdx].subtasks || [];
                        const sub = subs.find(st => (st.id || `${parentId}::${subs.indexOf(st)}`) === sid);
                        if (sub) {
                            const newTodo = { text: sub.text || '', ownerName: userName || getUserNameFromStorage(), due: '', tags: [], createdBy: userName || getUserNameFromStorage(), createdAt: new Date().toISOString(), order: nextTodoOrder++ };
                            newTodo.id = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                            localTodos.push(newTodo);
                            localTodos[tIdx].subtasks = subs.filter(st => (st.id || `${parentId}::${subs.indexOf(st)}`) !== sid);
                            renderTodosLocal();
                        }
                    }
                } else {
                    // Online: need the real subtask doc
                    const subRef = getSubtasksRef(parentId);
                    // We cannot fetch here without network; assume sid is Firestore id when online
                    const newTodo = { text: '', ownerName: userName || getUserNameFromStorage(), due: '', tags: [], createdBy: userName || getUserNameFromStorage(), createdAt: new Date().toISOString(), order: nextTodoOrder++ };
                    try {
                        // Create placeholder; we'll try to delete the subtask if sid exists
                        await addDoc(getTodosRef(), newTodo);
                        try { await deleteDoc(doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', parentId, 'subtasks', sid)); } catch {}
                    } catch (err) { console.error('Promote via drag failed', err); }
                }
            });
        }
                        window.location.href = '/';
                    }
                }
            // (removed duplicate inline handler; now bound above)
            });

            // Settings modal
            settingsBtn.addEventListener('click', () => { updateSettingsStatusUI(); settingsModal.classList.remove('hidden'); settingsModal.classList.add('flex'); });
            closeSettingsBtn.addEventListener('click', () => { settingsModal.classList.add('hidden'); settingsModal.classList.remove('flex'); });

            // GitHub source link
            if (githubBtn) githubBtn.addEventListener('click', () => { window.open('https://github.com/DoctorKhan/PomPom', '_blank'); });
            // AI features are now server-side - no user key management needed

            // Todos
            todoAddBtn.addEventListener('click', async () => { await addTodo(); });
            todoIdeaInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTodo(); });

            // Global Enter key: advance from visible screen (avoid when typing)
            document.addEventListener('keydown', (e) => {
                if (e.key !== 'Enter') return;
                const tag = (e.target && e.target.tagName) || '';
                const typing = tag === 'INPUT' || tag === 'TEXTAREA';
                // If on the name input page and not actively typing elsewhere, submit
                if (!nameInputPage.classList.contains('hidden') && !typing) {
                    e.preventDefault();
                    startSessionBtn.click();
                    return;
                }
                // If on landing page and not typing, go to next screen
                if (!landingPage.classList.contains('hidden') && !typing) {
                    e.preventDefault();
                    createSessionBtn.click();
                }
            });

            // Global spacebar handler for timer control
            document.addEventListener('keydown', (e) => {
                // Only handle spacebar on session page and when not typing in inputs
                if (e.code === 'Space' && !sessionPage.classList.contains('hidden')) {
                    // Don't trigger if user is typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    e.preventDefault();
                    startPauseBtn.click();
                }
            });
        }

        // --- FIRESTORE PATHS ---
        const getSessionRef = () => doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId);
        const getParticipantsRef = () => collection(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'participants');
        const getUserRef = (uid) => doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'participants', uid);
        const getChatRef = () => collection(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'chat');
    const getPlannerRef = () => collection(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'schedule');
    const getTodosRef = () => collection(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos');
        const getGoalsRef = () => collection(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'goals');
    const getSubtasksRef = (todoId) => collection(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', todoId, 'subtasks');

        // --- SESSION & USER LOGIC ---
    async function joinSession() {
            if (OFFLINE_MODE) return;
            try {
                const sessionRef = getSessionRef();
                const sessionSnap = await getDoc(sessionRef);
                if (!sessionSnap.exists()) {
                    await setDoc(sessionRef, { mode: 'pomodoro25', lastFocusMode: 'pomodoro25', duration: TIMER_MODES.pomodoro25.duration, isRunning: false, startTime: null, createdAt: serverTimestamp() });
                }
    await setDoc(getUserRef(userId), { name: (userName || getUserNameFromStorage()), joinedAt: serverTimestamp(), timeZone: getLocalTimeZone() }, { merge: true });
                startListening();
            } catch (error) { console.error("Error joining session:", error); }
        }

        function startListening() {
            if (OFFLINE_MODE) {
                if (alarmCheckInterval) clearInterval(alarmCheckInterval);
                alarmCheckInterval = setInterval(checkAlarms, 1000);
                return;
            }
            if (sessionUnsubscribe) sessionUnsubscribe();
            sessionUnsubscribe = onSnapshot(getSessionRef(), updateTimerUI);
            if (participantsUnsubscribe) participantsUnsubscribe();
            participantsUnsubscribe = onSnapshot(getParticipantsRef(), updateParticipantsUI);
            if (chatUnsubscribe) chatUnsubscribe();
            chatUnsubscribe = onSnapshot(query(getChatRef(), orderBy("createdAt")), updateChatUI);
            if (plannerUnsubscribe) plannerUnsubscribe();
            plannerUnsubscribe = onSnapshot(query(getPlannerRef(), orderBy("time")), updatePlannerUI);
            if (!OFFLINE_MODE) {
                if (window._goalsUnsub) window._goalsUnsub();
                window._goalsUnsub = onSnapshot(query(getGoalsRef(), orderBy('startedAt')), (snap) => {
                    try {
                        const list = [];
                        snap.forEach(doc => list.push({ id: doc.id, ...doc.data() }));
                        // Mirror to local for unified render
                        localStorage.setItem(goalStorageKey(), JSON.stringify(list));
                        renderGoals();
                    } catch (e) { console.warn('Goals snapshot failed', e); }
                });
            }
            if (todosUnsubscribe) todosUnsubscribe();
            todosUnsubscribe = onSnapshot(query(getTodosRef(), orderBy('order')), updateTodosUI);
            if (alarmCheckInterval) clearInterval(alarmCheckInterval);
            alarmCheckInterval = setInterval(checkAlarms, 1000);
        }

        function getUserNameFromStorage() {
            let name = localStorage.getItem('pompom_username');
            if (!name) {
                name = generateRandomUserName();
                localStorage.setItem('pompom_username', name);
            }
            return name;
        }

        function getTeamNameFromStorage() {
            return localStorage.getItem('pompom_team_name') || '';
        }

        function generateRandomUserName() {
            const adjectives = ["Fluffy", "Cloud", "Puffy", "Soft", "Bouncy", "Cheerful", "Sparkly", "Dreamy"];
            const nouns = ["Cloud", "Pomeranian", "Puff", "Buddy", "Angel", "Star", "Fluff", "Cotton"];
            return `${adjectives[Math.floor(Math.random() * adjectives.length)]} ${nouns[Math.floor(Math.random() * nouns.length)]}`;
        }

        function generateRandomTeamName() {
            const adjectives = ["Fluffy", "Cloud", "Dreamy", "Soft", "Puffy", "Cotton", "Misty", "Snowy"];
            const nouns = ["Clouds", "Pomeranians", "Squad", "Team", "Pack", "Fluffs", "Angels", "Cottons"];
            return `${adjectives[Math.floor(Math.random() * adjectives.length)]}-${nouns[Math.floor(Math.random() * nouns.length)]}`;
        }


        function populateRandomNames() {
            teamNameInput.value = generateRandomTeamName().replace('-', ' ');
            userNameSetupInput.value = generateRandomUserName();
            updateTeamLinkPreview();
            validateStartCta();
        }

        function updateUserNameUI() {
            // Update avatar with initials and tooltip
            const initials = userName.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
            userAvatar.textContent = initials;
            userAvatar.title = `${userName} (click to edit)`;
        }

        // Alias for consistency
        const updateUserDisplay = updateUserNameUI;

    async function updateName() {
            userNameInput.readOnly = true;
            const newName = userNameInput.value.trim();
            if (newName && newName !== userName) {
                userName = newName;
                localStorage.setItem('pompom_username', userName);
                updateUserNameUI();
                if (!OFFLINE_MODE) {
            await setDoc(getUserRef(userId), { name: (userName || getUserNameFromStorage()), timeZone: getLocalTimeZone() }, { merge: true });
                } else {
                    updateParticipantsOffline();
                }
            } else {
                userNameInput.value = userName;
            }
        }

        // --- TIMER LOGIC ---
        function renderTimerFromLocalState() {
            const data = { ...localSessionState };
            const wasRunning = startPauseBtn.textContent === 'Pause';
            clearInterval(timerInterval);
            timerModeDisplay.textContent = TIMER_MODES[data.mode].label;
            startPauseBtn.textContent = data.isRunning ? 'Pause ⏸️' : 'Start ✨';
            // Auto-carry over: if a new focus session starts and there is no active goal, carry over last incomplete
            (async () => {
                if (OFFLINE_MODE) {
                    const list = loadGoals();
                    const hasActive = list.some(g => g.status === 'active');
                    if (!hasActive && TIMER_MODES[data.mode].type === 'focus') {
                        const lastIncomplete = [...list].reverse().find(g => g.status === 'partial' || g.status === 'failed');
                        if (lastIncomplete) {
                            list.push({ id: Date.now(), text: lastIncomplete.text, status: 'active', startedAt: Date.now(), carried: true });
                            saveGoals(list);
                            renderGoals();
                        }
                    }
                } else {
                    try {
                        const snap = await getDocs(getGoalsRef());
                        const docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                        const hasActive = docs.some(g => g.status === 'active');
                        if (!hasActive && TIMER_MODES[data.mode].type === 'focus') {
                            const lastIncomplete = [...docs].reverse().find(g => g.status === 'partial' || g.status === 'failed');
                            if (lastIncomplete) {
                                await addDoc(getGoalsRef(), { text: lastIncomplete.text, status: 'active', startedAt: serverTimestamp(), carried: true, createdBy: userName || getUserNameFromStorage() });
                            }
                        }
                    } catch (e) { console.warn('Carry-over check failed', e); }
                }
                updateActiveModeButton(data.mode);
            })();

            const updateDisplay = () => {
                const start = data.startTime || Date.now();
                const elapsed = data.isRunning ? Date.now() - start : 0;
                const remaining = Math.max(0, (data.duration * 1000) - elapsed);

                if (wasRunning && remaining === 0) {
                    clearInterval(timerInterval);
                    if (data.isRunning) {
                        showEndOfSessionModal(data.mode, data.lastFocusMode);
                        data.isRunning = false;
                    }
                }

                const minutes = Math.floor((remaining / 1000) / 60);
                const seconds = Math.floor((remaining / 1000) % 60);
                timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            };

            updateDisplay();
            if (data.isRunning) timerInterval = setInterval(updateDisplay, 250);
        }

        function updateTimerUI(docSnap) {
            if (!docSnap.exists()) return;
            const data = docSnap.data();
            const wasRunning = startPauseBtn.textContent === 'Pause';

            clearInterval(timerInterval);
            timerModeDisplay.textContent = TIMER_MODES[data.mode].label;
            startPauseBtn.textContent = data.isRunning ? 'Pause ⏸️' : 'Start ✨';
            updateActiveModeButton(data.mode);

            const updateDisplay = () => {
                const serverStartTime = data.startTime ? data.startTime.toDate().getTime() : Date.now();
                const elapsed = data.isRunning ? Date.now() - serverStartTime : 0;
                const remaining = Math.max(0, (data.duration * 1000) - elapsed);

                if (wasRunning && remaining === 0) {
                    clearInterval(timerInterval);
                    if (data.isRunning) {
                       showEndOfSessionModal(data.mode, data.lastFocusMode);
                       updateDoc(getSessionRef(), { isRunning: false });
                    }
                }

                const minutes = Math.floor((remaining / 1000) / 60);
                const seconds = Math.floor((remaining / 1000) % 60);
                timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            };

            updateDisplay();
            if (data.isRunning) {
                timerInterval = setInterval(updateDisplay, 250);
            }
        }

        async function toggleTimer() {
            if (OFFLINE_MODE) {
                const isRunning = localSessionState.isRunning;
                if (isRunning) {
                    // Pause: compute remaining and store in duration
                    const elapsedMs = Date.now() - (localSessionState.startTime || Date.now());
                    const remaining = Math.max(0, localSessionState.duration - Math.floor(elapsedMs / 1000));
                    localSessionState.duration = remaining;
                    localSessionState.isRunning = false;
                    localSessionState.startTime = null;
                } else {
                    // Resume: keep current duration as remaining and start ticking
                    localSessionState.isRunning = true;
                    localSessionState.startTime = Date.now();
                }
                renderTimerFromLocalState();
                return;
            }
            const sessionRef = getSessionRef();
            const sessionSnap = await getDoc(sessionRef);
            if (!sessionSnap.exists()) return;
            const data = sessionSnap.data();
            if (data.isRunning) {
                // Pause: compute remaining based on server startTime
                const serverStart = data.startTime ? data.startTime.toDate().getTime() : Date.now();
                const elapsedSec = Math.floor((Date.now() - serverStart) / 1000);
                const remaining = Math.max(0, (data.duration || 0) - elapsedSec);
                await updateDoc(sessionRef, { isRunning: false, startTime: null, duration: remaining });
            } else {
                // Resume: start ticking from current duration
                await updateDoc(sessionRef, { isRunning: true, startTime: serverTimestamp() });
            }
        }

        async function resetTimer() {
            if (OFFLINE_MODE) {
                const currentMode = localSessionState.mode;
                localSessionState.isRunning = false;
                localSessionState.duration = TIMER_MODES[currentMode].duration;
                localSessionState.startTime = null;
                renderTimerFromLocalState();
                return;
            }
            const sessionRef = getSessionRef();
            const sessionSnap = await getDoc(sessionRef);
            if (!sessionSnap.exists()) return;
            const currentMode = sessionSnap.data().mode;
            await updateDoc(sessionRef, { isRunning: false, duration: TIMER_MODES[currentMode].duration, startTime: null });
        }

        async function setMode(mode) {
            if (OFFLINE_MODE) {
                localSessionState.mode = mode;
                localSessionState.duration = TIMER_MODES[mode].duration;
                localSessionState.isRunning = false;
                localSessionState.startTime = null;
                if (TIMER_MODES[mode].type === 'focus') localSessionState.lastFocusMode = mode;
                renderTimerFromLocalState();
                return;
            }
            const sessionRef = getSessionRef();
            const updates = {
                mode: mode,
                duration: TIMER_MODES[mode].duration,
                isRunning: false,
                startTime: null
            };
            if (TIMER_MODES[mode].type === 'focus') {
                updates.lastFocusMode = mode;
            }
            await updateDoc(sessionRef, updates);
        }

        // --- PARTICIPANTS & CHAT UI ---
        function updateParticipantsUI(snapshot) {
            participantsList.innerHTML = '';
            participantCount.textContent = snapshot.size;
            participantsTZByName = {};
            snapshot.docs.forEach(doc => {
                const user = doc.data();
                if (user?.name) {
                    participantsTZByName[user.name] = user.timeZone || participantsTZByName[user.name] || null;
                }
                const p = document.createElement('div');
                p.className = 'p-3 bg-white/10 rounded-lg flex items-center gap-3';
                p.innerHTML = `<div class="w-8 h-8 rounded-full bg-gradient-to-br from-white to-sky-100 flex items-center justify-center font-bold text-sm relative text-sky-600 shadow-lg border-2 border-white/50"><div class="absolute -top-1 -right-1 w-3 h-3 bg-gradient-to-br from-blue-200 to-blue-400 rounded-full kawaii-float shadow-sm flex items-center justify-center text-xs">☁️</div><div class="absolute -bottom-1 -left-1 w-3 h-3 bg-gradient-to-br from-yellow-200 to-yellow-400 rounded-full kawaii-float shadow-sm flex items-center justify-center text-xs" style="animation-delay: 0.5s">✨</div>${user.name.split(' ').map(n=>n[0]).join('').toUpperCase()}</div><span class="font-semibold text-sky-800">${user.name}</span>`;
                participantsList.appendChild(p);
            });
            // Refresh owner dropdown
            refreshOwnerSelect(snapshot.docs.map(d => d.data().name));
            // Rerender todos to reflect any updated time zones in due display
            try { if (!isEditingTodo && Array.isArray(currentTodos) && currentTodos.length) renderTodos(currentTodos); } catch {}
        }

        function updateParticipantsOffline() {
            participantsList.innerHTML = '';
            participantCount.textContent = 1;
            const p = document.createElement('div');
            const name = userName || getUserNameFromStorage();
            participantsTZByName = { [name]: getLocalTimeZone() };
            p.className = 'p-3 bg-white/10 rounded-lg flex items-center gap-3';
            p.innerHTML = `<div class="w-8 h-8 rounded-full bg-gradient-to-br from-white to-sky-100 flex items-center justify-center font-bold text-sm relative text-sky-600 shadow-lg border-2 border-white/50"><div class="absolute -top-1 -right-1 w-3 h-3 bg-gradient-to-br from-blue-200 to-blue-400 rounded-full kawaii-float shadow-sm flex items-center justify-center text-xs">☁️</div><div class="absolute -bottom-1 -left-1 w-3 h-3 bg-gradient-to-br from-yellow-200 to-yellow-400 rounded-full kawaii-float shadow-sm flex items-center justify-center text-xs" style="animation-delay: 0.5s">✨</div>${name.split(' ').map(n=>n[0]).join('').toUpperCase()}</div><span class="font-semibold text-sky-800">${name}</span>`;
            participantsList.appendChild(p);
            refreshOwnerSelect([name]);
            // Rerender todos to reflect local time zone
            try { if (!isEditingTodo && Array.isArray(currentTodos) && currentTodos.length) renderTodos(currentTodos); } catch {}
        }

        function updateChatUI(snapshot) {
            chatMessages.innerHTML = '';
            const messages = snapshot.docs.map(doc => doc.data());
            messages.forEach(msg => {
                 const m = document.createElement('div');
                 m.className = 'mb-2';
                 m.innerHTML = `<p><strong class="font-semibold">${msg.userName}</strong>: ${msg.text}</p>`;
                 chatMessages.appendChild(m);
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function renderLocalChat() {
            chatMessages.innerHTML = '';
            localChat.forEach(msg => {
                const m = document.createElement('div');
                m.className = 'mb-2';
                m.innerHTML = `<p><strong class="font-semibold">${msg.userName}</strong>: ${msg.text}</p>`;
                chatMessages.appendChild(m);
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        async function sendChatMessage() {
            const text = chatInput.value.trim();
            if (text) {
                if (OFFLINE_MODE) {
                    localChat.push({ userId: 'local', userName: userName || getUserNameFromStorage(), text, createdAt: new Date() });
                    renderLocalChat();
                    chatInput.value = '';

                } else {
                    await addDoc(getChatRef(), { userId, userName, text, createdAt: serverTimestamp() });
                    chatInput.value = '';
                }
            }
        }


        async function handleCreateCalendarEvent() {
            try {
                // Allow tests to run in offline mode if a test sign-in mock is present
        // --- Goal outcome prompt ---
        function promptGoalOutcome() {
            const localList = loadGoals();
            const localCurrent = localList.find(g => g.status === 'active');
            if (!localCurrent) return;
            const container = document.createElement('div');
            container.className = 'mt-2 flex gap-2';
            const makeBtn = (label, status) => {
                const b = document.createElement('button');
                b.className = 'btn btn-secondary text-xs px-4 py-2 rounded-lg font-semibold shadow-md hover:shadow-lg transition-all';
                const emoji = { success: '✅', partial: '🟡', failed: '❌' }[status] || '';
                b.textContent = `${emoji} ${label}`;
                b.addEventListener('click', async () => {
                    try {
                        if (OFFLINE_MODE) {
                            localCurrent.status = status;
                            localCurrent.endedAt = Date.now();
                            saveGoals(localList);
                        } else {
                            // Find active doc and update
                            const snap = await getDocs(getGoalsRef());
                            const active = snap.docs.find(d => d.data()?.status === 'active');
                            if (active) await updateDoc(doc(getGoalsRef(), active.id), { status });
                        }
                        renderGoals();
                        container.remove();
                        const statusMsg = status === 'success' ? 'Goal succeeded' : status === 'partial' ? 'Marked partial' : 'Marked failed';
                        showToast(statusMsg);
                        // Auto-post outcome to chat
                        const chatMsg = `${status === 'success' ? '✅' : status === 'partial' ? '🟡' : '❌'} ${statusMsg}: ${localCurrent.text}`;
                        if (OFFLINE_MODE) {
                            localChat.push({ userId: 'local', userName: userName || getUserNameFromStorage(), text: chatMsg, createdAt: new Date() });
                            renderLocalChat();
                        } else {
                            try {
                                await addDoc(getChatRef(), { userId, userName: userName || getUserNameFromStorage(), text: chatMsg, createdAt: serverTimestamp() });
                            } catch (e) { console.warn('Failed to post outcome to chat', e); }
                        }
                    } catch (e) { console.error('Failed to update goal status', e); }
                });
                return b;
            };
            container.appendChild(makeBtn('Succeeded', 'success'));
            container.appendChild(makeBtn('Partial', 'partial'));
            container.appendChild(makeBtn('Failed', 'failed'));
            if (currentGoalEl) currentGoalEl.after(container);
        }
                if (OFFLINE_MODE && !window.__TEST_GOOGLE_SIGNIN__) {
                    showToast('Google Calendar requires online mode');
                    return;
                }
                async function getGoogleAccessToken() {
                    if (window.__TEST_GOOGLE_SIGNIN__) {
                        const r = await window.__TEST_GOOGLE_SIGNIN__(auth);
                        return { accessToken: r.accessToken, user: r.user };
                    }
                    const provider = new GoogleAuthProvider();
                    provider.addScope('https://www.googleapis.com/auth/calendar.events');
                    provider.addScope('https://www.googleapis.com/auth/userinfo.email');
                    provider.setCustomParameters({ prompt: 'select_account consent' });
                    const result = await signInWithPopup(auth, provider);
                    const credential = GoogleAuthProvider.credentialFromResult(result);
                    return { accessToken: credential?.accessToken, user: result.user };
                }
                const { accessToken, user } = await getGoogleAccessToken();
                if (!accessToken) { showToast('Missing Google access token'); return; }

                const now = new Date();
                const durationSec = (TIMER_MODES[localSessionState?.mode || 'pomodoro25']?.duration) || 25*60;
                const start = new Date(now.getTime() + 60*1000);
                const end = new Date(start.getTime() + durationSec*1000);
                const event = {
                    summary: `PomPom Focus — ${teamNameInput?.value || sessionId || 'Session'}`,
                    description: `Created from PomPom by ${user?.displayName || userName || 'User'}`,
                    start: { dateTime: start.toISOString() },
                    end: { dateTime: end.toISOString() },
                    conferenceData: { createRequest: { requestId: `${Date.now()}` } },
                };

                const doFetch = window.__TEST_FETCH__ || fetch;
                const resp = await doFetch('https://www.googleapis.com/calendar/v3/calendars/primary/events?conferenceDataVersion=1', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify(event)
                });
                if (!resp.ok) { const text = await (resp.text ? resp.text() : ''); throw new Error(text || `Calendar API error ${resp.status}`); }
                const data = await resp.json();
                const meetLink = data.hangoutLink || (data.conferenceData?.entryPoints||[]).find(e=>e.entryPointType==='video')?.uri || '';

                const msg = `${user?.displayName || user?.email || 'Someone'} created a meeting: ${meetLink || data.htmlLink}`;
                if (OFFLINE_MODE) {
                    localChat.push({ userId: 'local', userName: user?.displayName || 'You', text: msg, createdAt: new Date() });
                    renderLocalChat();
                } else {
                    await addDoc(getChatRef(), { userId, userName: userName || user?.displayName || user?.email || 'User', text: msg, createdAt: serverTimestamp() });
                }
                switchView('chat');
                showToast('Calendar event created');
            } catch (e) {
                console.error('Create calendar event failed', e);
                showToast('Calendar event failed');
            }
        }

        // --- PLANNER & ALARM LOGIC ---
        function initAudioAndNotifications() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (Notification.permission !== "granted") Notification.requestPermission();
        }

        function playAlarm() {
            if (!isSoundEnabled || !audioCtx) return;
            // Gentle chime: short arpeggio with envelope and low-pass filter
            const sequence = [
                { freq: 784 },    // G5
                { freq: 880 },    // A5
                { freq: 987.77 }, // B5
                { freq: 1174.66 } // D6
            ];
            const start = audioCtx.currentTime;
            const baseGain = 0.15;
            const noteDur = 0.18;
            const gap = 0.06;
            sequence.forEach((n, i) => {
                const t0 = start + i * (noteDur + gap);
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 4000;
                osc.type = 'sine';
                osc.frequency.setValueAtTime(n.freq, t0);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                // Envelope: quick attack, short decay
                gain.gain.setValueAtTime(0.0001, t0);
                gain.gain.exponentialRampToValueAtTime(baseGain, t0 + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.0001, t0 + noteDur);
                osc.start(t0);
                osc.stop(t0 + noteDur + 0.02);
            });
        }

        function showNotification(event) {
            if (Notification.permission === "granted") {
                new Notification("Fluffy Cloud Alert! ☁️🐕☁️ ✨", { body: `Time for: ${event.description} (◕‿◕)♡`, icon: "https://placehold.co/64x64/0EA5E9/FFFFFF?text=☁️🐕" });
            }
        }

        function checkAlarms() {
            const now = new Date();
            const currentTotalMinutes = now.getHours() * 60 + now.getMinutes();
            if (currentTotalMinutes !== lastCheckedMinute) {
                lastCheckedMinute = currentTotalMinutes;
                const currentTimeHHMM = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                scheduledEvents.forEach(event => {
                    if (event.time === currentTimeHHMM) {
                        playAlarm();
                        showNotification(event);
                    }
                });
            }
        }

        async function scheduleNewPomodoro() {
            const time = scheduleTimeInput.value;
            const description = scheduleDescInput.value.trim();
            if (time && description) {
                try {
                    if (OFFLINE_MODE) {
                        const event = { id: `${Date.now()}`, time, description, scheduledBy: userName || getUserNameFromStorage(), createdAt: new Date() };
                        scheduledEvents.push(event);
                        renderPlannerLocal();
                        scheduleTimeInput.value = '';
                        scheduleDescInput.value = '';
                    } else {
                        await addDoc(getPlannerRef(), { time, description, scheduledBy: userName, createdAt: serverTimestamp() });
                        scheduleTimeInput.value = '';
                        scheduleDescInput.value = '';
                    }
                } catch (error) { console.error("Error scheduling Pomodoro:", error); }
            }
        }

        function updatePlannerUI(snapshot) {
            plannerList.innerHTML = '';
            scheduledEvents = [];
            snapshot.forEach(doc => {
                const event = { id: doc.id, ...doc.data() };
                scheduledEvents.push(event);
                const item = document.createElement('div');
                item.className = 'p-3 bg-white/10 rounded-lg flex items-center gap-4';
                item.innerHTML = `<div class="text-xl font-bold text-sky-800">${event.time}</div><div class="flex-grow"><div class="font-semibold text-sky-800">${event.description}</div><div class="text-sm text-sky-600">Scheduled by ${event.scheduledBy}</div></div>`;
                plannerList.appendChild(item);
            });
        }

        function renderPlannerLocal() {
            plannerList.innerHTML = '';
            scheduledEvents
                .slice()
                .sort((a,b) => a.time.localeCompare(b.time))
                .forEach(event => {
                    const item = document.createElement('div');
                    item.className = 'p-3 bg-white/10 rounded-lg flex items-center gap-4';
                    item.innerHTML = `<div class="text-xl font-bold text-sky-800">${event.time}</div><div class="flex-grow"><div class="font-semibold text-sky-800">${event.description}</div><div class="text-sm text-sky-600">Scheduled by ${event.scheduledBy}</div></div>`;
                    plannerList.appendChild(item);
                });
        }
        function toSlug(s) {
            return (s || '')
                .toString()
                .trim()
                .toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9-]/g, '')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '');
        }
        function updateTeamLinkPreview() {
            try { teamLinkSlug.textContent = toSlug(teamNameInput.value) || 'your-team'; } catch {}
        }
        function validateStartCta() {
            const hasTeam = !!(teamNameInput?.value || '').trim();
            const hasUser = !!(userNameSetupInput?.value || '').trim();
            const ready = hasTeam && hasUser;
            if (startSessionBtn) {
                startSessionBtn.disabled = !ready;
                startSessionBtn.classList.toggle('opacity-60', !ready);
                startSessionBtn.classList.toggle('cursor-not-allowed', !ready);
            }
            if (enterHint) enterHint.classList.toggle('hidden', !ready);
        }

        function toggleSound() {
            isSoundEnabled = !isSoundEnabled;
            localStorage.setItem('pompom_sound_enabled', isSoundEnabled);
            updateSoundUI();
        }

        function updateSoundUI() {
            const icon = isSoundEnabled ?
                `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-volume-up-fill" viewBox="0 0 16 16"><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/><path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.483 5.483 0 0 1 11.025 8a5.483 5.483 0 0 1-1.61 3.89l.706.706z"/><path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.49 3.49 0 0 1 8 10.475l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z"/></svg>` :
                `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-volume-mute-fill" viewBox="0 0 16 16"><path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zm7.137 2.096a.5.5 0 0 1 0 .708L12.207 8l1.647 1.646a.5.5 0 0 1-.708.708L11.5 8.707l-1.646 1.647a.5.5 0 0 1-.708-.708L10.793 8 9.146 6.354a.5.5 0 1 1 .708-.708L11.5 7.293l1.646-1.647a.5.5 0 0 1 .708 0z"/></svg>`;
            soundToggleBtn.innerHTML = icon;
        }

        // ===== Groq API integration via backend proxy =====
        async function callGroqAPI(prompt, history = []) {
            try {
                const messages = [];

                for (const item of history) {
                    messages.push({ role: item.role, content: item.content });
                }
                if (!prompt || !prompt.trim()) throw new Error('Prompt cannot be empty');
                messages.push({ role: 'user', content: prompt.trim() });
                const body = {
                    model: 'llama-3.1-8b-instant',
                    messages,
                    max_tokens: 500,
                    temperature: 0.7,
                    stream: false
                };

                // Use backend proxy instead of direct API call
                const res = await fetch('/api/groq', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({}));
                    if (res.status === 429) {
                        throw new Error('Rate limit exceeded. Please try again later.');
                    } else if (res.status === 503) {
                        throw new Error('AI service not configured. Please contact the administrator.');
                    }
                    throw new Error(errorData.error || `AI service error ${res.status}`);
                }

                const data = await res.json();
                const content = data?.choices?.[0]?.message?.content?.trim();
                if (!content) throw new Error('Invalid AI response');
                return content;
            } catch (err) {
                console.error('AI request failed:', err);
                return `AI temporarily unavailable: ${err.message}`;
            }
        }

        function updateSettingsStatusUI() {
            // Check if server-side AI is available
            fetch('/api/health').then(res => res.json()).then(data => {
                apiKeyStatusText.textContent = data.groqConfigured ? 'Server-side configured' : 'Not configured';
                aiFeaturesStatus.textContent = data.groqConfigured ? 'Enabled (shared)' : 'Disabled';
            }).catch(() => {
                apiKeyStatusText.textContent = 'Server unavailable';
                aiFeaturesStatus.textContent = 'Disabled';
            });
            applyAdvancedVisibility();
        }

        function advancedFeaturesOn() {
            // Advanced features are on when we're online (server handles AI)
            return !OFFLINE_MODE;
        }

        // User toggle: persisted mode (advanced/basic) via checkbox
    function getUserFeatureToggleOn() {
            try {
        const saved = (localStorage.getItem('pompom_feature_mode') || 'basic');
                const savedOn = saved === 'advanced';
                // If checkbox exists, reflect saved state
                if (featureModeToggle) featureModeToggle.checked = !!savedOn;
                return !!savedOn;
            } catch { return false; }
        }

    function applyAdvancedVisibility() {
            try {
                // Require both: environment supports advanced AND user toggle is on
                const envOn = advancedFeaturesOn();
                const userOn = getUserFeatureToggleOn();
                const on = envOn && userOn;

                // Nav icons
                viewPlannerBtn.classList.toggle('hidden', !on);
                calendarEventBtn.classList.toggle('hidden', !on);

                // Views (hide if turning off and currently visible)
                if (!on) {
                    plannerView.classList.add('hidden');
                    if (!timerView.classList.contains('hidden')) {
                        // already on timer
                    } else {
                        switchView('timer');
                    }
                }

                // Settings modal AI features section
                const aiSection = document.getElementById('ai-features-section');
                if (aiSection) {
                    aiSection.classList.toggle('hidden', !on);
                }

                // Status label next to checkbox
                const status = document.getElementById('feature-mode-status');
                if (status) {
                    if (on) status.textContent = 'Todos + Planner + Calendar + AI Features';
                    else if (!userOn) status.textContent = 'Basic timer mode only';
                    else status.textContent = 'Unavailable (needs online connection)';
                }
            } catch {}
        }

        function refreshOwnerSelect(names) {
            // Owner selection is automatic; keep for backward compatibility (no-op)
            return;
        }

        function getTeamMembersForAI() {
            // Use participants list DOM to gather names (works both online/offline after render)
            return Array.from(participantsList.querySelectorAll('span.font-semibold'))
                .map(el => el.textContent)
                .filter(Boolean);
        }

        function extractJSON(text) {
            try { return JSON.parse(text); } catch {}
            const match = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
            if (match) { try { return JSON.parse(match[1]); } catch {} }
            const braceStart = text.indexOf('{');
            const braceEnd = text.lastIndexOf('}');
            if (braceStart >= 0 && braceEnd > braceStart) {
                const candidate = text.slice(braceStart, braceEnd + 1);
                try { return JSON.parse(candidate); } catch {}
            }
            return null;
        }

        function getLocalTimeZone() {
            try { return Intl.DateTimeFormat().resolvedOptions().timeZone || null; } catch { return null; }
        }

        function formatDateTimeForOwner(dueISO, ownerName) {
            if (!dueISO) return '—';
            const ownerTZ = participantsTZByName[ownerName] || null;
            try {
                const dt = new Date(dueISO);
                if (isNaN(dt.getTime())) return '—';
                const opts = { dateStyle: 'medium', timeStyle: 'short', hour12: true, timeZone: ownerTZ || undefined };
                return new Intl.DateTimeFormat(undefined, opts).format(dt) + (ownerTZ ? ` (${ownerTZ.split('/').pop().replace('_',' ')})` : '');
            } catch {
                try { return new Date(dueISO).toLocaleString(); } catch { return '—'; }
            }
        }

        function toISOFromAny(suggested) {
            if (!suggested) return '';
            // If it's a local-like string (no timezone), interpret as local then convert to UTC ISO
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(suggested)) {
                const d = new Date(suggested);
                if (!isNaN(d.getTime())) return d.toISOString();
            }
            const d = new Date(suggested);
            if (!isNaN(d.getTime())) return d.toISOString();
            return '';
        }

        async function suggestTodo(idea) {
            const members = getTeamMembersForAI();
            const nowISO = new Date().toISOString();
            const prompt = `You are an assistant helping a remote team manage todos. Improve the task text, pick an owner from this list: ${JSON.stringify(members)} (must be exactly one of these names), and suggest a due datetime within the next 7 days. Respond ONLY as compact JSON with keys: improvedText, owner, due. due should be ISO like 2025-08-13T17:00.\nTask: ${idea}\nCurrent time: ${nowISO}`;
            const res = await callGroqAPI(prompt);
            const obj = extractJSON(res) || {};
            // Fallback due: next day at 17:00 local
            const fallbackDue = (() => {
                const d = new Date();
                d.setDate(d.getDate() + 1);
                d.setHours(17, 0, 0, 0);
                const yyyy = d.getFullYear();
                const mm = String(d.getMonth()+1).padStart(2,'0');
                const dd = String(d.getDate()).padStart(2,'0');
                const hh = String(d.getHours()).padStart(2,'0');
                const min = String(d.getMinutes()).padStart(2,'0');
                return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
            })();
            return {
                text: obj.improvedText || idea,
                ownerName: obj.owner || (userName || getUserNameFromStorage()),
                due: obj.due ? toISOFromAny(obj.due) : fallbackDue
            };
        }

        async function addTodo() {
            if (!todoIdeaInput) return;
            const idea = (todoIdeaInput.value || '').trim();
            if (!idea) { if (todoStatus) todoStatus.textContent = 'Task text required.'; return; }
            if (todoStatus) todoStatus.textContent = 'Asking AI...';
            const suggestion = await suggestTodo(idea);
            // Prefer a due parsed from the user's idea text if present (e.g., "today", "in 2 days")
            const dueFromText = parseDueOrNull(idea) || parseDueOrNull(suggestion.text);
            // Extract tags from the suggested text (supports #tags)
            const { cleanText, tags } = extractTagsFromText(suggestion.text);
            const todo = {
                text: cleanText,
                ownerName: suggestion.ownerName,
                due: toISOFromAny(dueFromText || suggestion.due || '') || '',
                tags: tags,
                createdBy: userName || getUserNameFromStorage(),
                createdAt: new Date().toISOString(),
                order: nextTodoOrder++
            };
            try {
                if (OFFLINE_MODE) { todo.id = `${Date.now()}`; localTodos.push(todo); renderTodosLocal(); }
                else { await addDoc(getTodosRef(), todo); }
                if (todoIdeaInput) todoIdeaInput.value = '';
                if (todoStatus) todoStatus.textContent = 'Added.';
            } catch (e) {
                console.error('Add todo failed', e);
                if (todoStatus) todoStatus.textContent = 'Failed to add todo.';
            }
        }

        function updateTodosUI(snapshot) {
            if (isEditingTodo) return; // avoid clobbering inline editor during edit
            const todos = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
            // Normalize order for any missing items
            const withOrder = todos.map((t, i) => ({ ...t, order: typeof t.order === 'number' ? t.order : i }));
            const sorted = withOrder.slice().sort((a,b) => a.order - b.order);
            currentTodos = sorted;
            nextTodoOrder = sorted.length ? Math.max(...sorted.map(t => t.order)) + 1 : 0;
            renderTodos(sorted);
        }

        function renderTodosLocal() {
            if (isEditingTodo) return;
            // Ensure order
            localTodos = localTodos.map((t, i) => ({ ...t, order: typeof t.order === 'number' ? t.order : i }));
            const sorted = localTodos.slice().sort((a,b) => a.order - b.order);
            currentTodos = sorted;
            nextTodoOrder = sorted.length ? Math.max(...sorted.map(t => t.order)) + 1 : 0;
            renderTodos(sorted);
        }
    function renderTodos(items) {
            if (!todoList) return;
            todoList.innerHTML = '';
            if (!items || items.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'text-sky-800';
                empty.textContent = 'No todos yet.';
                todoList.appendChild(empty);
                return;
            }
            items.forEach((t, idx) => {
                const div = document.createElement('div');
                div.className = 'p-4 bg-gradient-to-r from-white/15 to-white/10 hover:from-white/20 hover:to-white/15 rounded-xl border border-white/20 shadow-sm transition-all duration-200 flex items-start gap-4 mb-3';
                div.setAttribute('draggable', 'true');
                div.dataset.id = t.id || String(t.createdAt || idx);
                div.dataset.order = String(t.order ?? idx);

                const dragHandle = document.createElement('div');
                dragHandle.className = 'cursor-move text-sky-600 hover:text-sky-800 select-none text-lg mt-1';
                dragHandle.title = 'Drag to reorder';
                dragHandle.innerHTML = '⋮⋮';

                const content = document.createElement('div');
                content.className = 'flex-1 cursor-pointer min-w-0';
                content.title = 'Click to edit';
                content.setAttribute('role', 'button');
                content.setAttribute('tabindex', '0');

                // Action buttons container
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'flex items-start gap-2 flex-shrink-0';
                const dueText = formatDateTimeForOwner(t.due, t.ownerName || '');
        const tagsHtml = (t.tags && t.tags.length) ? `<div class=\"mt-1 flex flex-wrap gap-1\">${t.tags.map(tag => `<span class=\"text-xs px-2 py-0.5 rounded-full bg-sky-200/70 text-sky-800\">#${escapeHtml(tag)}</span>`).join('')}</div>` : '';
        content.innerHTML = `<div class=\"font-semibold text-sky-900 todo-text\">${escapeHtml(t.text || '')}</div><div class=\"text-sm text-sky-700\">Owner: <span class=\"todo-owner\">${escapeHtml(t.ownerName || '')}</span> • Due: <span class=\"todo-due\">${escapeHtml(dueText)}</span></div>${tagsHtml}<div class=\"text-xs text-sky-600 mt-1 opacity-60\">Click to edit</div>`;

                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-secondary px-3 py-1 text-sm';
                editBtn.textContent = 'Edit';
                editBtn.addEventListener('click', (e) => { e.stopPropagation(); isEditingTodo = true; startInlineEdit(div, t); });

                const breakdownBtn = document.createElement('button');
                breakdownBtn.className = 'btn btn-secondary px-3 py-1 text-sm';
                breakdownBtn.textContent = 'Break down';
                breakdownBtn.title = 'Use AI to break this task down into subtasks';
                breakdownBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await startBreakdownFlow(t, div);
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn bg-red-500 hover:bg-red-600 text-white px-3 py-1 text-sm';
                deleteBtn.innerHTML = '🗑️';
                deleteBtn.title = 'Delete this task';
                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    if (confirm(`Delete task: "${t.text}"?\n\nThis will also delete all subtasks.`)) {
                        await deleteTodo(t);
                    }
                });
                // Enable click-to-edit on the main content area
                content.addEventListener('click', (e) => {
                    if (div.dataset.editing === 'true') return; // ignore clicks while already editing
                    const target = e.target;
                    let focusField = 'text';
                    if (target && (target.classList?.contains('todo-due') || target.closest?.('.todo-due'))) focusField = 'due';
                    else if (target && (target.classList?.contains('todo-owner') || target.closest?.('.todo-owner'))) focusField = 'owner';
                    startInlineEdit(div, t, { focus: focusField });
                });
                // Keyboard accessibility: Enter or Space triggers edit
                content.addEventListener('keydown', (e) => {
                    if (div.dataset.editing === 'true') return;
                    if (e.key === 'Enter' || e.code === 'Space') {
                        e.preventDefault();
                        startInlineEdit(div, t);
                    }
                });

                // Add buttons to actions container
                actionsContainer.appendChild(editBtn);
                actionsContainer.appendChild(breakdownBtn);
                actionsContainer.appendChild(deleteBtn);

                div.appendChild(dragHandle);
                div.appendChild(content);
                div.appendChild(actionsContainer);

                // Drag and drop events
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);

                // Subtasks container with improved visual hierarchy
                const subtasksContainer = document.createElement('div');
                subtasksContainer.className = 'ml-6 mt-3 pl-4 border-l-2 border-sky-200/50 space-y-2 bg-gradient-to-r from-sky-50/20 to-transparent rounded-r-lg';
                subtasksContainer.dataset.parentId = div.dataset.id;

                // Add a subtle header for subtasks when they exist
                const subtasksHeader = document.createElement('div');
                subtasksHeader.className = 'text-xs text-sky-600 font-medium mb-2 hidden';
                subtasksHeader.innerHTML = '📋 Subtasks';
                subtasksContainer.appendChild(subtasksHeader);

                div.appendChild(subtasksContainer);
                todoList.appendChild(div);
                // Load subtasks (online only; offline stored in-memory)
                if (!OFFLINE_MODE && t.id) {
                    const parentId = t.id;
                    const subRef = getSubtasksRef(parentId);
                    onSnapshot(query(subRef, orderBy('order')), (snap) => renderSubtasks(subtasksContainer, parentId, snap.docs.map(d => ({ id: d.id, ...d.data() }))));
                } else {
                    renderSubtasks(subtasksContainer, t.id || div.dataset.id, (t.subtasks || []).slice().sort((a,b)=> (a.order||0)-(b.order||0)));
                }
            });
        }

        async function startBreakdownFlow(todo, container) {
            try { if (todoStatus) todoStatus.textContent = 'Asking AI to break it down…'; } catch {}
            const prompt = `Break the following task into 3-7 clear, actionable subtasks that can be completed in under an hour each. Keep each subtask concise. Respond ONLY as JSON array of objects: [{"text":"..."}].\nTask: ${todo.text}`;
            const res = await callGroqAPI(prompt);
            const data = extractJSON(res);
            const subtasks = Array.isArray(data) ? data.map((s, i) => ({ text: String(s.text||'').trim(), done: false, order: i })) : [];
            const parentId = todo.id || container.dataset.id;
            if (OFFLINE_MODE) {
                // Attach in-memory
                const idx = localTodos.findIndex(x => (x.id || String(x.createdAt)) === parentId);
                if (idx >= 0) {
                    localTodos[idx].subtasks = subtasks;
                    renderTodosLocal();
                }
            } else {
                // Store under todos/{id}/subtasks
                for (let i = 0; i < subtasks.length; i++) {
                    await addDoc(getSubtasksRef(parentId), { text: subtasks[i].text, done: false, order: i, createdAt: serverTimestamp() });
                }
            }
            try { if (todoStatus) todoStatus.textContent = ''; } catch {}
        }

        async function deleteTodo(todo) {
            try {
                if (OFFLINE_MODE) {
                    // Remove from local array
                    const idx = localTodos.findIndex(x => (x.id || String(x.createdAt)) === (todo.id || String(todo.createdAt)));
                    if (idx >= 0) {
                        localTodos.splice(idx, 1);
                        renderTodosLocal();
                    }
                } else {
                    // Delete from Firestore (this will also delete subcollections via security rules or manual cleanup)
                    if (todo.id) {
                        const todoRef = doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', todo.id);
                        await deleteDoc(todoRef);

                        // Also delete all subtasks
                        try {
                            const subtasksRef = collection(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', todo.id, 'subtasks');
                            const subtasksSnapshot = await getDocs(subtasksRef);
                            const deletePromises = subtasksSnapshot.docs.map(doc => deleteDoc(doc.ref));
                            await Promise.all(deletePromises);
                        } catch (e) {
                            console.warn('Failed to delete subtasks:', e);
                        }
                    }
                }
                if (todoStatus) todoStatus.textContent = 'Task deleted.';
                setTimeout(() => { if (todoStatus) todoStatus.textContent = ''; }, 2000);
            } catch (e) {
                console.error('Delete todo failed:', e);
                if (todoStatus) todoStatus.textContent = 'Failed to delete task.';
            }
        }

        function renderSubtasks(container, parentId, items) {
            // Clear container but preserve the header
            const header = container.querySelector('.text-xs.text-sky-600');
            container.innerHTML = '';
            if (header) container.appendChild(header);

            if (!items || !items.length) {
                if (header) header.classList.add('hidden');
                return;
            }

            // Show header when subtasks exist
            if (header) header.classList.remove('hidden');
            items.forEach((s, idx) => {
                const row = document.createElement('div');
                row.className = 'flex items-center gap-3 bg-white/10 hover:bg-white/20 rounded-lg px-3 py-2 border border-white/20 transition-colors';
                row.setAttribute('draggable', 'true');
                row.dataset.sid = s.id || `${parentId}::${idx}`;
                row.dataset.order = String(s.order ?? idx);

                const drag = document.createElement('div');
                drag.className = 'cursor-move text-sky-600 hover:text-sky-800 select-none text-sm';
                drag.innerHTML = '⋮⋮';

                const chk = document.createElement('input');
                chk.type = 'checkbox';
                chk.className = 'w-4 h-4 text-sky-600 rounded focus:ring-sky-500';
                chk.checked = !!s.done;
                chk.addEventListener('change', async () => {
                    if (OFFLINE_MODE) { s.done = chk.checked; return; }
                    if (!parentId || !s.id) return;
                    await updateDoc(doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', parentId, 'subtasks', s.id), { done: !!chk.checked });
                });

                const txt = document.createElement('input');
                txt.type = 'text';
                txt.className = 'flex-1 bg-white/10 border border-white/30 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent text-sky-900 text-sm';
                txt.value = s.text || '';
                txt.placeholder = 'Subtask description...';
                txt.addEventListener('change', async () => {
                    if (OFFLINE_MODE) { s.text = txt.value; return; }
                    if (!parentId || !s.id) return;
                    await updateDoc(doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', parentId, 'subtasks', s.id), { text: txt.value });
                });

                const promote = document.createElement('button');
                promote.className = 'btn btn-secondary px-2 py-0.5 text-xs';
                promote.textContent = '↗️';
                promote.title = 'Promote to main task';
                promote.addEventListener('click', async () => {
                    const newTodo = {
                        text: txt.value.trim() || s.text || '',
                        ownerName: (s.ownerName || '') || (userName || getUserNameFromStorage()),
                        due: '', tags: [], createdBy: userName || getUserNameFromStorage(), createdAt: new Date().toISOString(), order: nextTodoOrder++
                    };
                    if (OFFLINE_MODE) {
                        newTodo.id = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                        localTodos.push(newTodo);
                        // Remove from subtasks
                        const tIdx = localTodos.findIndex(x => (x.id || String(x.createdAt)) === parentId);
                        if (tIdx >= 0) {
                            localTodos[tIdx].subtasks = (localTodos[tIdx].subtasks || []).filter(st => (st.id || `${parentId}::${localTodos[tIdx].subtasks.indexOf(st)}`) !== (s.id || `${parentId}::${idx}`));
                        }
                        renderTodosLocal();
                    } else {
                        await addDoc(getTodosRef(), newTodo);
                        // Delete the subtask
                        if (s.id) {
                            await deleteDoc(doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', parentId, 'subtasks', s.id));
                        }
                    }
                });

                const deleteSubtask = document.createElement('button');
                deleteSubtask.className = 'btn bg-red-500 hover:bg-red-600 text-white px-2 py-0.5 text-xs';
                deleteSubtask.innerHTML = '🗑️';
                deleteSubtask.title = 'Delete this subtask';
                deleteSubtask.addEventListener('click', async () => {
                    if (confirm(`Delete subtask: "${s.text}"?`)) {
                        if (OFFLINE_MODE) {
                            // Remove from local subtasks
                            const tIdx = localTodos.findIndex(x => (x.id || String(x.createdAt)) === parentId);
                            if (tIdx >= 0) {
                                localTodos[tIdx].subtasks = (localTodos[tIdx].subtasks || []).filter(st => (st.id || `${parentId}::${localTodos[tIdx].subtasks.indexOf(st)}`) !== (s.id || `${parentId}::${idx}`));
                                renderTodosLocal();
                            }
                        } else {
                            if (s.id) {
                                await deleteDoc(doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', parentId, 'subtasks', s.id));
                            }
                        }
                    }
                });

                row.appendChild(drag);
                row.appendChild(chk);
                row.appendChild(txt);
                row.appendChild(promote);
                row.appendChild(deleteSubtask);
                container.appendChild(row);
            });
        }

        // Inline edit for todo: text, owner, due (natural language), tags.
        function startInlineEdit(container, todo, opts = {}) {
            const content = container.querySelector('.flex-1');
            if (!content) return;
            const members = getTeamMembersForAI();
            ensureOwnerDatalist(members);
            container.setAttribute('draggable', 'false');
            isEditingTodo = true;
            container.dataset.editing = 'true';

            const original = { text: todo.text || '', ownerName: todo.ownerName || (userName || getUserNameFromStorage()), due: todo.due || '', tags: Array.isArray(todo.tags) ? todo.tags : [] };
            const dueDisplay = original.due ? formatDateTimeForOwner(original.due, original.ownerName) : ''; // human readable
            // Prefer a stable, editable local ISO without seconds for selection UX
            const toLocalNoSeconds = (iso) => {
                try {
                    const d = new Date(iso);
                    if (isNaN(d.getTime())) return '';
                    const yyyy = d.getFullYear();
                    const mm = String(d.getMonth()+1).padStart(2,'0');
                    const dd = String(d.getDate()).padStart(2,'0');
                    const hh = String(d.getHours()).padStart(2,'0');
                    const min = String(d.getMinutes()).padStart(2,'0');
                    return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
                } catch { return ''; }
            };
            const dueISOForInput = original.due ? toLocalNoSeconds(original.due) : '';

            const wrapper = document.createElement('div');
            wrapper.className = 'w-full grid grid-cols-1 md:grid-cols-4 gap-2 items-start';

            const textInput = document.createElement('input');
            textInput.type = 'text';
            textInput.value = original.text;
            textInput.placeholder = 'Task description';
            textInput.className = 'w-full bg-white text-sky-800 px-2 py-2 rounded-md focus:outline-none';

            const ownerInput = document.createElement('input');
            ownerInput.type = 'text';
            ownerInput.value = original.ownerName;
            ownerInput.setAttribute('list', 'owner-datalist');
            ownerInput.placeholder = 'Owner (name)';
            ownerInput.className = 'w-full bg-white text-sky-800 px-2 py-2 rounded-md focus:outline-none';

            const dueInput = document.createElement('input');
            dueInput.type = 'text';
            // Prefer a raw local string if available to improve editability
            dueInput.value = dueISOForInput || dueDisplay || '';
            dueInput.placeholder = 'Due (e.g., "tomorrow 5pm", "in 2 days", "Fri 3pm")';
            dueInput.className = 'w-full bg-white text-sky-800 px-2 py-2 rounded-md focus:outline-none';

            const tagsInput = document.createElement('input');
            tagsInput.type = 'text';
            tagsInput.value = original.tags.map(t => `#${t}`).join(' ');
            tagsInput.placeholder = 'Tags (e.g., #bug urgent)';
            tagsInput.className = 'w-full bg-white text-sky-800 px-2 py-2 rounded-md focus:outline-none';

            const actions = document.createElement('div');
            actions.className = 'col-span-1 md:col-span-4 flex gap-2 mt-1 items-center';
            const saveBtn = document.createElement('button');
            saveBtn.className = 'btn btn-secondary px-4';
            saveBtn.textContent = 'Save';
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn btn-primary px-4';
            cancelBtn.textContent = 'Cancel';
            const statusSpan = document.createElement('span');
            statusSpan.className = 'text-sm text-sky-700 opacity-80 ml-2';
            statusSpan.textContent = '';
            actions.appendChild(saveBtn);
            actions.appendChild(cancelBtn);
            actions.appendChild(statusSpan);

            // Replace content
            content.innerHTML = '';
            const label1 = document.createElement('div'); label1.className = 'text-xs text-sky-700 md:col-span-4'; label1.textContent = 'Edit and press Enter to save, or click Save. First click selects all; second click places the caret. Natural dates and #tags are OK.';
            wrapper.appendChild(textInput);
            wrapper.appendChild(ownerInput);
            wrapper.appendChild(dueInput);
            wrapper.appendChild(tagsInput);
            content.appendChild(label1);
            content.appendChild(wrapper);
            content.appendChild(actions);

            const doCancel = () => { isEditingTodo = false; container.dataset.editing = 'false'; renderTodos(currentTodos); };
            cancelBtn.addEventListener('click', doCancel);

            // First focus selects all; second click switches to caret insertion
            const selectAll = (el) => { try { el.focus(); el.select(); } catch {} };
            let firstFocusDone = false;
            let dirty = false;
            [textInput, ownerInput, dueInput, tagsInput].forEach(el => {
                el.addEventListener('focus', () => { if (!firstFocusDone) { selectAll(el); firstFocusDone = true; } });
                el.addEventListener('mousedown', (e) => {
                    if (!firstFocusDone) { e.preventDefault(); selectAll(el); firstFocusDone = true; }
                });
                el.addEventListener('input', () => { dirty = true; });
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); doSave(); }
                    if (e.key === 'Escape') { e.preventDefault(); doCancel(); }
                });
                // No auto-save on blur; commit via Enter or Save button only
            });
            // Focus requested field and select all on first open
            const f = (opts && opts.focus) || 'text';
            if (f === 'owner') { ownerInput.focus(); ownerInput.select(); }
            else if (f === 'due') { dueInput.focus(); dueInput.select(); }
            else { textInput.focus(); textInput.select(); }

            const doSave = async () => {
                try { statusSpan.textContent = 'Saving…'; } catch {}
                saveBtn.disabled = true; cancelBtn.disabled = true;
                const input = {
                    text: (textInput.value || '').trim(),
                    owner: (ownerInput.value || '').trim(),
                    due: (dueInput.value || '').trim(),
                    tags: (tagsInput.value || '').trim()
                };
                // Normalize via AI when key available; else fallback parser
                const normalized = await normalizeTodoFields(input, members);
                // Merge tags from text (hashtags) and tags input
                const tagSet = new Set([...(normalized.tags || []), ...parseTagsFromString(input.tags), ...extractTagsFromText(normalized.text).tags, ...extractTagsFromText(input.text).tags]);
                const cleanText = extractTagsFromText(normalized.text).cleanText;
                const updates = {
                    text: cleanText || original.text,
                    ownerName: normalized.ownerName || original.ownerName,
                    due: toISOFromAny(normalized.due || original.due) || '',
                    tags: Array.from(tagSet)
                };
                try {
                    if (OFFLINE_MODE) {
                        const idx = localTodos.findIndex(x => x.id === todo.id);
                        if (idx >= 0) Object.assign(localTodos[idx], updates);
                        // Defer render until after flags reset
                    } else {
                        const ref = doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', todo.id);
                        await updateDoc(ref, updates);
                    }
                } catch (e) { console.error('Edit failed', e); try { statusSpan.textContent = 'Error saving'; } catch {} }
                finally {
                    isEditingTodo = false;
                    container.dataset.editing = 'false';
                    if (OFFLINE_MODE) {
                        renderTodosLocal();
                    } else {
                        // Optimistic UI update so the user immediately sees the change
                        try {
                            const idx = currentTodos.findIndex(x => x.id === todo.id);
                            if (idx >= 0) {
                                currentTodos[idx] = { ...currentTodos[idx], ...updates };
                                renderTodos(currentTodos);
                            }
                        } catch {}
                    }
                }
            };

            saveBtn.addEventListener('click', doSave);
            [textInput, ownerInput, dueInput, tagsInput].forEach(el => {
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        doCancel();
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        doSave();
                    }
                });
            });
        }

        function ensureOwnerDatalist(members) {
            let dl = document.getElementById('owner-datalist');
            if (!dl) {
                dl = document.createElement('datalist');
                dl.id = 'owner-datalist';
                document.body.appendChild(dl);
            }
            dl.innerHTML = '';
            members.forEach(n => { const opt = document.createElement('option'); opt.value = n; dl.appendChild(opt); });
        }

        async function normalizeTodoFields(input, members) {
            const fallback = {};
            // Local owner match
            const owner = bestMatchOwner(input.owner, members) || (userName || getUserNameFromStorage());
            // Local due parse
            const dueLocal = normalizeDueLocal(input.due);
            fallback.ownerName = owner;
            fallback.due = dueLocal;
            fallback.text = input.text || '';
            fallback.tags = parseTagsFromString(input.tags);

            // Check if server-side AI is available (no client-side API key needed)
            if (OFFLINE_MODE || !advancedFeaturesOn()) return fallback;
            try {
                const nowISO = new Date().toISOString();
                const prompt = `Normalize this todo for a team. Team members: ${JSON.stringify(members)}. Pick owner as the best match from that list. Extract tags from text or tags string (hashtags like #bug and plain terms) as an array of lower-case words without '#'. Convert the due string to an ISO local date-time (YYYY-MM-DDTHH:MM) within 7 days if it is relative (like 'today', 'tomorrow', 'in 2 days', 'fri 3pm'); if no due provided, set to tomorrow 17:00 local. Respond ONLY as JSON with keys: text, ownerName, due, tags.\nInput: ${JSON.stringify(input)}\nNow: ${nowISO}`;
                const res = await callGroqAPI(prompt);
                const obj = extractJSON(res) || {};
                const dueISO = toISOFromAny(obj.due) || fallback.due;
                const ownerName = (obj.ownerName || obj.owner || '').trim();
                const ownerFixed = bestMatchOwner(ownerName, members) || fallback.ownerName;
                const tags = Array.isArray(obj.tags) ? obj.tags.map(t => String(t).toLowerCase().replace(/^#/,'')).filter(Boolean) : fallback.tags;
                return { text: obj.text || fallback.text, ownerName: ownerFixed, due: dueISO, tags };
            } catch (e) {
                console.warn('AI normalize failed, using fallback', e);
                return fallback;
            }
        }

        function bestMatchOwner(inputName, members) {
            const me = (userName || getUserNameFromStorage());
            if (!members || !members.length) return me;
            const norm = (s) => (s||'').toLowerCase().trim();
            const target = norm(inputName);
            if (!target) return me;
            // exact
            const exact = members.find(m => norm(m) === target);
            if (exact) return exact;
            // startsWith any token
            const tokens = target.split(/\s+/).filter(Boolean);
            const sw = members.find(m => tokens.some(t => norm(m).startsWith(t)));
            if (sw) return sw;
            // includes
            const inc = members.find(m => tokens.some(t => norm(m).includes(t)));
            if (inc) return inc;
            return me;
        }

        function normalizeDueLocal(text) {
            const t = (text||'').trim().toLowerCase();
            const d = new Date();
            const setTime = (hh=17, mm=0) => { d.setHours(hh, mm, 0, 0); };
            const fmt = (dt) => {
                const yyyy = dt.getFullYear();
                const mm = String(dt.getMonth()+1).padStart(2,'0');
                const dd = String(dt.getDate()).padStart(2,'0');
                const hh = String(dt.getHours()).padStart(2,'0');
                const min = String(dt.getMinutes()).padStart(2,'0');
                return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
            };
            if (!t) { d.setDate(d.getDate()+1); setTime(); return fmt(d); }
            const weekdayMap = { sunday:0, monday:1, tuesday:2, wednesday:3, thursday:4, friday:5, saturday:6, sun:0, mon:1, tue:2, tues:2, wed:3, thu:4, thur:4, thurs:4, fri:5, sat:6 };
            const timeMatch = t.match(/\b(\d{1,2})(?::(\d{2}))?\s*(am|pm)?\b/);
            const setFromTime = () => {
                if (!timeMatch) { setTime(); return; }
                let hh = parseInt(timeMatch[1],10);
                const mm = timeMatch[2] ? parseInt(timeMatch[2],10) : 0;
                const ap = timeMatch[3];
                if (ap) {
                    if (ap === 'pm' && hh < 12) hh += 12;
                    if (ap === 'am' && hh === 12) hh = 0;
                }
                setTime(hh, mm);
            };
            // today/tomorrow
            if (/\btoday\b/.test(t)) {
                if (!timeMatch) {
                    const now = new Date();
                    const cand = new Date(d);
                    cand.setHours(now.getHours()+1, 0, 0, 0); // next round hour today
                    return fmt(cand);
                }
                setFromTime();
                return fmt(d);
            }
            if (/\btomorrow\b/.test(t)) { d.setDate(d.getDate()+1); setFromTime(); return fmt(d); }
            // in X days/hours
            const inDays = t.match(/in\s+(\d+)\s+days?/);
            if (inDays) { d.setDate(d.getDate()+parseInt(inDays[1],10)); setFromTime(); return fmt(d); }
            const inHours = t.match(/in\s+(\d+)\s+hours?/);
            if (inHours) { d.setHours(d.getHours()+parseInt(inHours[1],10)); setFromTime(); return fmt(d); }
            // weekday or next weekday
            const wd = Object.keys(weekdayMap).find(w => new RegExp(`\\b${w}\\b`).test(t));
            if (wd) {
                const target = weekdayMap[wd];
                const cur = d.getDay();
                let diff = (target - cur + 7) % 7;
                if (diff === 0) diff = 7; // next occurrence
                d.setDate(d.getDate()+diff);
                setFromTime();
                return fmt(d);
            }
            // absolute date parse fallback
            const parsed = new Date(text);
            if (!isNaN(parsed.getTime())) return fmt(parsed);
            // default fallback
            d.setDate(d.getDate()+1); setTime(); return fmt(d);
        }

        // Detect if text contains recognizable relative/weekday tokens; return normalized ISO or null
        function parseDueOrNull(text) {
            const t = (text||'').toLowerCase();
            const hasToken = /(\btoday\b|\btomorrow\b|in\s+\d+\s+(days?|hours?)\b|\b(sun|mon|tue|tues|wed|thu|thur|thurs|fri|sat|sunday|monday|tuesday|wednesday|thursday|friday|saturday)\b)/i.test(t);
            if (!hasToken) return null;
            return normalizeDueLocal(text);
        }

        // --- Tags helpers ---
        function parseTagsFromString(str) {
            const s = (str || '').trim();
            if (!s) return [];
            const hash = (s.match(/#[a-z0-9_-]+/gi) || []).map(t => t.slice(1).toLowerCase());
            const words = s
                .split(/[\s,]+/)
                .map(w => w.replace(/^#/, ''))
                .map(w => w.trim().toLowerCase())
                .filter(Boolean);
            return Array.from(new Set([...hash, ...words]));
        }
        function extractTagsFromText(text) {
            const tags = Array.from(new Set((text.match(/#[a-z0-9_-]+/gi) || []).map(t => t.slice(1).toLowerCase())));
            const cleanText = text.replace(/#[a-z0-9_-]+/gi, '').replace(/\s{2,}/g, ' ').trim();
            return { cleanText, tags };
        }
        function escapeHtml(s) {
            return String(s || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Drag & drop reorder
        let draggedId = null;
        function handleDragStart(e) {
            draggedId = this.dataset.id;
            e.dataTransfer.effectAllowed = 'move';
            this.classList.add('opacity-70');
        }
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        async function handleDrop(e) {
            e.preventDefault();
            const targetId = this.dataset.id;
            if (!draggedId || draggedId === targetId) return;
            const list = currentTodos.slice();
            const from = list.findIndex(t => (t.id || String(t.createdAt)) === draggedId);
            const to = list.findIndex(t => (t.id || String(t.createdAt)) === targetId);
            if (from < 0 || to < 0) return;
            const [moved] = list.splice(from, 1);
            list.splice(to, 0, moved);
            // Reassign order sequentially
            list.forEach((t, i) => t.order = i);
            currentTodos = list;
            renderTodos(list);
            // Persist
            if (OFFLINE_MODE) {
                localTodos = list.map(t => ({ ...t }));
            } else {
                try {
                    // Batch update orders
                    for (const t of list) {
                        const ref = doc(db, 'artifacts', appId, 'public/data/pompom_sessions', sessionId, 'todos', t.id);
                        await updateDoc(ref, { order: t.order });
                    }
                } catch (e) { console.error('Reorder failed', e); }
            }
        }
        function handleDragEnd() {
            this.classList.remove('opacity-70');
            draggedId = null;
        }

    // Note: Subtasks reorder persistence is handled by promoting/demoting or future enhancement.

    // --- START THE APP ---
    init();
    </script>
</body>
</html>
